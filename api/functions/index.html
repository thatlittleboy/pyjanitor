
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="canonical" href="https://pyjanitor-devs.github.io/pyjanitor/api/functions/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.6">
    
    
      
        <title>Functions - pyjanitor documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.a57b2b03.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.3f5d1f46.min.css">
        
          
          
          <meta name="theme-color" content="#546d78">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../../css/nb_mods.css">
    
      <link rel="stylesheet" href="../../css/apidocs.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/nord.min.css">
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue-grey" data-md-color-accent="blue-grey">
  
    
    <script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#functions" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="pyjanitor documentation" class="md-header__button md-logo" aria-label="pyjanitor documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-7.5-3.5-14.3-8.9-18.7-4.2-15.4-4.2-59.3 0-74.7 5.4-4.3 8.9-11.1 8.9-18.6zM128 134c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm0 64c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm253.4 250H96c-17.7 0-32-14.3-32-32 0-17.6 14.4-32 32-32h285.4c-1.9 17.1-1.9 46.9 0 64z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            pyjanitor documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Functions
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/pyjanitor-devs/pyjanitor/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    pyjanitor-devs/pyjanitor
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="pyjanitor documentation" class="md-nav__button md-logo" aria-label="pyjanitor documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-7.5-3.5-14.3-8.9-18.7-4.2-15.4-4.2-59.3 0-74.7 5.4-4.3 8.9-11.1 8.9-18.6zM128 134c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm0 64c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm253.4 250H96c-17.7 0-32-14.3-32-32 0-17.6 14.4-32 32-32h285.4c-1.9 17.1-1.9 46.9 0 64z"/></svg>

    </a>
    pyjanitor documentation
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/pyjanitor-devs/pyjanitor/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    pyjanitor-devs/pyjanitor
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../devguide/" class="md-nav__link">
        Development Guide
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          API Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="API Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Functions
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Functions
      </a>
      
        


<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#janitor.functions" class="md-nav__link">
    janitor.functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions--general-functions" class="md-nav__link">
    General Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.add_columns" class="md-nav__link">
    add_columns
  </a>
  
    <nav class="md-nav" aria-label="add_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.add_columns.add_column" class="md-nav__link">
    add_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.add_columns.add_columns" class="md-nav__link">
    add_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.also" class="md-nav__link">
    also
  </a>
  
    <nav class="md-nav" aria-label="also">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.also.also" class="md-nav__link">
    also()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.bin_numeric" class="md-nav__link">
    bin_numeric
  </a>
  
    <nav class="md-nav" aria-label="bin_numeric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.bin_numeric.bin_numeric" class="md-nav__link">
    bin_numeric()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.case_when" class="md-nav__link">
    case_when
  </a>
  
    <nav class="md-nav" aria-label="case_when">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.case_when.case_when" class="md-nav__link">
    case_when()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.change_type" class="md-nav__link">
    change_type
  </a>
  
    <nav class="md-nav" aria-label="change_type">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.change_type.change_type" class="md-nav__link">
    change_type()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.clean_names" class="md-nav__link">
    clean_names
  </a>
  
    <nav class="md-nav" aria-label="clean_names">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.clean_names.clean_names" class="md-nav__link">
    clean_names()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.coalesce" class="md-nav__link">
    coalesce
  </a>
  
    <nav class="md-nav" aria-label="coalesce">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.coalesce.coalesce" class="md-nav__link">
    coalesce()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.collapse_levels" class="md-nav__link">
    collapse_levels
  </a>
  
    <nav class="md-nav" aria-label="collapse_levels">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.collapse_levels.collapse_levels" class="md-nav__link">
    collapse_levels()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.complete" class="md-nav__link">
    complete
  </a>
  
    <nav class="md-nav" aria-label="complete">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.complete.complete" class="md-nav__link">
    complete()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.concatenate_columns" class="md-nav__link">
    concatenate_columns
  </a>
  
    <nav class="md-nav" aria-label="concatenate_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.concatenate_columns.concatenate_columns" class="md-nav__link">
    concatenate_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.conditional_join" class="md-nav__link">
    conditional_join
  </a>
  
    <nav class="md-nav" aria-label="conditional_join">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.conditional_join.conditional_join" class="md-nav__link">
    conditional_join()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.convert_date" class="md-nav__link">
    convert_date
  </a>
  
    <nav class="md-nav" aria-label="convert_date">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.convert_date.convert_excel_date" class="md-nav__link">
    convert_excel_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.convert_date.convert_matlab_date" class="md-nav__link">
    convert_matlab_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.convert_date.convert_unix_date" class="md-nav__link">
    convert_unix_date()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.count_cumulative_unique" class="md-nav__link">
    count_cumulative_unique
  </a>
  
    <nav class="md-nav" aria-label="count_cumulative_unique">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.count_cumulative_unique.count_cumulative_unique" class="md-nav__link">
    count_cumulative_unique()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.currency_column_to_numeric" class="md-nav__link">
    currency_column_to_numeric
  </a>
  
    <nav class="md-nav" aria-label="currency_column_to_numeric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.currency_column_to_numeric.currency_column_to_numeric" class="md-nav__link">
    currency_column_to_numeric()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.deconcatenate_column" class="md-nav__link">
    deconcatenate_column
  </a>
  
    <nav class="md-nav" aria-label="deconcatenate_column">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.deconcatenate_column.deconcatenate_column" class="md-nav__link">
    deconcatenate_column()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.drop_constant_columns" class="md-nav__link">
    drop_constant_columns
  </a>
  
    <nav class="md-nav" aria-label="drop_constant_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.drop_constant_columns.drop_constant_columns" class="md-nav__link">
    drop_constant_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.drop_duplicate_columns" class="md-nav__link">
    drop_duplicate_columns
  </a>
  
    <nav class="md-nav" aria-label="drop_duplicate_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.drop_duplicate_columns.drop_duplicate_columns" class="md-nav__link">
    drop_duplicate_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.dropnotnull" class="md-nav__link">
    dropnotnull
  </a>
  
    <nav class="md-nav" aria-label="dropnotnull">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.dropnotnull.dropnotnull" class="md-nav__link">
    dropnotnull()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.encode_categorical" class="md-nav__link">
    encode_categorical
  </a>
  
    <nav class="md-nav" aria-label="encode_categorical">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.encode_categorical.encode_categorical" class="md-nav__link">
    encode_categorical()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.expand_column" class="md-nav__link">
    expand_column
  </a>
  
    <nav class="md-nav" aria-label="expand_column">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.expand_column.expand_column" class="md-nav__link">
    expand_column()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.expand_grid" class="md-nav__link">
    expand_grid
  </a>
  
    <nav class="md-nav" aria-label="expand_grid">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.expand_grid.expand_grid" class="md-nav__link">
    expand_grid()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.factorize_columns" class="md-nav__link">
    factorize_columns
  </a>
  
    <nav class="md-nav" aria-label="factorize_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.factorize_columns.factorize_columns" class="md-nav__link">
    factorize_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.fill" class="md-nav__link">
    fill
  </a>
  
    <nav class="md-nav" aria-label="fill">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.fill.fill_direction" class="md-nav__link">
    fill_direction()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.fill.fill_empty" class="md-nav__link">
    fill_empty()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.filter" class="md-nav__link">
    filter
  </a>
  
    <nav class="md-nav" aria-label="filter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_column_isin" class="md-nav__link">
    filter_column_isin()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_date" class="md-nav__link">
    filter_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_on" class="md-nav__link">
    filter_on()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_string" class="md-nav__link">
    filter_string()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.find_replace" class="md-nav__link">
    find_replace
  </a>
  
    <nav class="md-nav" aria-label="find_replace">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.find_replace.find_replace" class="md-nav__link">
    find_replace()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.flag_nulls" class="md-nav__link">
    flag_nulls
  </a>
  
    <nav class="md-nav" aria-label="flag_nulls">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.flag_nulls.flag_nulls" class="md-nav__link">
    flag_nulls()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.get_dupes" class="md-nav__link">
    get_dupes
  </a>
  
    <nav class="md-nav" aria-label="get_dupes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.get_dupes.get_dupes" class="md-nav__link">
    get_dupes()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.groupby_agg" class="md-nav__link">
    groupby_agg
  </a>
  
    <nav class="md-nav" aria-label="groupby_agg">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.groupby_agg.groupby_agg" class="md-nav__link">
    groupby_agg()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.groupby_topk" class="md-nav__link">
    groupby_topk
  </a>
  
    <nav class="md-nav" aria-label="groupby_topk">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.groupby_topk.groupby_topk" class="md-nav__link">
    groupby_topk()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.impute" class="md-nav__link">
    impute
  </a>
  
    <nav class="md-nav" aria-label="impute">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.impute.impute" class="md-nav__link">
    impute()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.jitter" class="md-nav__link">
    jitter
  </a>
  
    <nav class="md-nav" aria-label="jitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.jitter.jitter" class="md-nav__link">
    jitter()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.join_apply" class="md-nav__link">
    join_apply
  </a>
  
    <nav class="md-nav" aria-label="join_apply">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.join_apply.join_apply" class="md-nav__link">
    join_apply()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.label_encode" class="md-nav__link">
    label_encode
  </a>
  
    <nav class="md-nav" aria-label="label_encode">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.label_encode.label_encode" class="md-nav__link">
    label_encode()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.limit_column_characters" class="md-nav__link">
    limit_column_characters
  </a>
  
    <nav class="md-nav" aria-label="limit_column_characters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.limit_column_characters.limit_column_characters" class="md-nav__link">
    limit_column_characters()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.min_max_scale" class="md-nav__link">
    min_max_scale
  </a>
  
    <nav class="md-nav" aria-label="min_max_scale">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.min_max_scale.min_max_scale" class="md-nav__link">
    min_max_scale()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.move" class="md-nav__link">
    move
  </a>
  
    <nav class="md-nav" aria-label="move">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.move.move" class="md-nav__link">
    move()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.pivot" class="md-nav__link">
    pivot
  </a>
  
    <nav class="md-nav" aria-label="pivot">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.pivot.pivot_longer" class="md-nav__link">
    pivot_longer()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.pivot.pivot_wider" class="md-nav__link">
    pivot_wider()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.process_text" class="md-nav__link">
    process_text
  </a>
  
    <nav class="md-nav" aria-label="process_text">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.process_text.process_text" class="md-nav__link">
    process_text()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.remove_columns" class="md-nav__link">
    remove_columns
  </a>
  
    <nav class="md-nav" aria-label="remove_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.remove_columns.remove_columns" class="md-nav__link">
    remove_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.remove_empty" class="md-nav__link">
    remove_empty
  </a>
  
    <nav class="md-nav" aria-label="remove_empty">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.remove_empty.remove_empty" class="md-nav__link">
    remove_empty()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.rename_columns" class="md-nav__link">
    rename_columns
  </a>
  
    <nav class="md-nav" aria-label="rename_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.rename_columns.rename_column" class="md-nav__link">
    rename_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.rename_columns.rename_columns" class="md-nav__link">
    rename_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.reorder_columns" class="md-nav__link">
    reorder_columns
  </a>
  
    <nav class="md-nav" aria-label="reorder_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.reorder_columns.reorder_columns" class="md-nav__link">
    reorder_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.round_to_fraction" class="md-nav__link">
    round_to_fraction
  </a>
  
    <nav class="md-nav" aria-label="round_to_fraction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.round_to_fraction.round_to_fraction" class="md-nav__link">
    round_to_fraction()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.row_to_names" class="md-nav__link">
    row_to_names
  </a>
  
    <nav class="md-nav" aria-label="row_to_names">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.row_to_names.row_to_names" class="md-nav__link">
    row_to_names()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.select_columns" class="md-nav__link">
    select_columns
  </a>
  
    <nav class="md-nav" aria-label="select_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.select_columns.select_columns" class="md-nav__link">
    select_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.shuffle" class="md-nav__link">
    shuffle
  </a>
  
    <nav class="md-nav" aria-label="shuffle">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.shuffle.shuffle" class="md-nav__link">
    shuffle()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.sort_column_value_order" class="md-nav__link">
    sort_column_value_order
  </a>
  
    <nav class="md-nav" aria-label="sort_column_value_order">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.sort_column_value_order.sort_column_value_order" class="md-nav__link">
    sort_column_value_order()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.sort_naturally" class="md-nav__link">
    sort_naturally
  </a>
  
    <nav class="md-nav" aria-label="sort_naturally">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.sort_naturally.sort_naturally" class="md-nav__link">
    sort_naturally()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.take_first" class="md-nav__link">
    take_first
  </a>
  
    <nav class="md-nav" aria-label="take_first">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.take_first.take_first" class="md-nav__link">
    take_first()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.then" class="md-nav__link">
    then
  </a>
  
    <nav class="md-nav" aria-label="then">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.then.then" class="md-nav__link">
    then()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.to_datetime" class="md-nav__link">
    to_datetime
  </a>
  
    <nav class="md-nav" aria-label="to_datetime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.to_datetime.to_datetime" class="md-nav__link">
    to_datetime()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.toset" class="md-nav__link">
    toset
  </a>
  
    <nav class="md-nav" aria-label="toset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.toset.toset" class="md-nav__link">
    toset()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.transform_columns" class="md-nav__link">
    transform_columns
  </a>
  
    <nav class="md-nav" aria-label="transform_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.transform_columns.transform_column" class="md-nav__link">
    transform_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.transform_columns.transform_columns" class="md-nav__link">
    transform_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.truncate_datetime" class="md-nav__link">
    truncate_datetime
  </a>
  
    <nav class="md-nav" aria-label="truncate_datetime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.truncate_datetime.truncate_datetime_dataframe" class="md-nav__link">
    truncate_datetime_dataframe()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.update_where" class="md-nav__link">
    update_where
  </a>
  
    <nav class="md-nav" aria-label="update_where">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.update_where.update_where" class="md-nav__link">
    update_where()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.utils" class="md-nav__link">
    utils
  </a>
  
    <nav class="md-nav" aria-label="utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.utils.patterns" class="md-nav__link">
    patterns()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.utils.unionize_dataframe_categories" class="md-nav__link">
    unionize_dataframe_categories()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../biology/" class="md-nav__link">
        Biology
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../chemistry/" class="md-nav__link">
        Chemistry
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../engineering/" class="md-nav__link">
        Engineering
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../finance/" class="md-nav__link">
        Finance
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../io/" class="md-nav__link">
        Input/Output (io)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ml/" class="md-nav__link">
        Machine Learning
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../math/" class="md-nav__link">
        Math
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../pyspark/" class="md-nav__link">
        PySpark
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../timeseries/" class="md-nav__link">
        Timeseries
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../xarray/" class="md-nav__link">
        XArray
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../CHANGELOG/" class="md-nav__link">
        Changelog
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../AUTHORS/" class="md-nav__link">
        Authors
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#janitor.functions" class="md-nav__link">
    janitor.functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions--general-functions" class="md-nav__link">
    General Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.add_columns" class="md-nav__link">
    add_columns
  </a>
  
    <nav class="md-nav" aria-label="add_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.add_columns.add_column" class="md-nav__link">
    add_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.add_columns.add_columns" class="md-nav__link">
    add_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.also" class="md-nav__link">
    also
  </a>
  
    <nav class="md-nav" aria-label="also">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.also.also" class="md-nav__link">
    also()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.bin_numeric" class="md-nav__link">
    bin_numeric
  </a>
  
    <nav class="md-nav" aria-label="bin_numeric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.bin_numeric.bin_numeric" class="md-nav__link">
    bin_numeric()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.case_when" class="md-nav__link">
    case_when
  </a>
  
    <nav class="md-nav" aria-label="case_when">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.case_when.case_when" class="md-nav__link">
    case_when()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.change_type" class="md-nav__link">
    change_type
  </a>
  
    <nav class="md-nav" aria-label="change_type">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.change_type.change_type" class="md-nav__link">
    change_type()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.clean_names" class="md-nav__link">
    clean_names
  </a>
  
    <nav class="md-nav" aria-label="clean_names">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.clean_names.clean_names" class="md-nav__link">
    clean_names()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.coalesce" class="md-nav__link">
    coalesce
  </a>
  
    <nav class="md-nav" aria-label="coalesce">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.coalesce.coalesce" class="md-nav__link">
    coalesce()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.collapse_levels" class="md-nav__link">
    collapse_levels
  </a>
  
    <nav class="md-nav" aria-label="collapse_levels">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.collapse_levels.collapse_levels" class="md-nav__link">
    collapse_levels()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.complete" class="md-nav__link">
    complete
  </a>
  
    <nav class="md-nav" aria-label="complete">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.complete.complete" class="md-nav__link">
    complete()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.concatenate_columns" class="md-nav__link">
    concatenate_columns
  </a>
  
    <nav class="md-nav" aria-label="concatenate_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.concatenate_columns.concatenate_columns" class="md-nav__link">
    concatenate_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.conditional_join" class="md-nav__link">
    conditional_join
  </a>
  
    <nav class="md-nav" aria-label="conditional_join">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.conditional_join.conditional_join" class="md-nav__link">
    conditional_join()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.convert_date" class="md-nav__link">
    convert_date
  </a>
  
    <nav class="md-nav" aria-label="convert_date">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.convert_date.convert_excel_date" class="md-nav__link">
    convert_excel_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.convert_date.convert_matlab_date" class="md-nav__link">
    convert_matlab_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.convert_date.convert_unix_date" class="md-nav__link">
    convert_unix_date()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.count_cumulative_unique" class="md-nav__link">
    count_cumulative_unique
  </a>
  
    <nav class="md-nav" aria-label="count_cumulative_unique">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.count_cumulative_unique.count_cumulative_unique" class="md-nav__link">
    count_cumulative_unique()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.currency_column_to_numeric" class="md-nav__link">
    currency_column_to_numeric
  </a>
  
    <nav class="md-nav" aria-label="currency_column_to_numeric">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.currency_column_to_numeric.currency_column_to_numeric" class="md-nav__link">
    currency_column_to_numeric()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.deconcatenate_column" class="md-nav__link">
    deconcatenate_column
  </a>
  
    <nav class="md-nav" aria-label="deconcatenate_column">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.deconcatenate_column.deconcatenate_column" class="md-nav__link">
    deconcatenate_column()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.drop_constant_columns" class="md-nav__link">
    drop_constant_columns
  </a>
  
    <nav class="md-nav" aria-label="drop_constant_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.drop_constant_columns.drop_constant_columns" class="md-nav__link">
    drop_constant_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.drop_duplicate_columns" class="md-nav__link">
    drop_duplicate_columns
  </a>
  
    <nav class="md-nav" aria-label="drop_duplicate_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.drop_duplicate_columns.drop_duplicate_columns" class="md-nav__link">
    drop_duplicate_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.dropnotnull" class="md-nav__link">
    dropnotnull
  </a>
  
    <nav class="md-nav" aria-label="dropnotnull">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.dropnotnull.dropnotnull" class="md-nav__link">
    dropnotnull()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.encode_categorical" class="md-nav__link">
    encode_categorical
  </a>
  
    <nav class="md-nav" aria-label="encode_categorical">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.encode_categorical.encode_categorical" class="md-nav__link">
    encode_categorical()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.expand_column" class="md-nav__link">
    expand_column
  </a>
  
    <nav class="md-nav" aria-label="expand_column">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.expand_column.expand_column" class="md-nav__link">
    expand_column()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.expand_grid" class="md-nav__link">
    expand_grid
  </a>
  
    <nav class="md-nav" aria-label="expand_grid">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.expand_grid.expand_grid" class="md-nav__link">
    expand_grid()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.factorize_columns" class="md-nav__link">
    factorize_columns
  </a>
  
    <nav class="md-nav" aria-label="factorize_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.factorize_columns.factorize_columns" class="md-nav__link">
    factorize_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.fill" class="md-nav__link">
    fill
  </a>
  
    <nav class="md-nav" aria-label="fill">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.fill.fill_direction" class="md-nav__link">
    fill_direction()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.fill.fill_empty" class="md-nav__link">
    fill_empty()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.filter" class="md-nav__link">
    filter
  </a>
  
    <nav class="md-nav" aria-label="filter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_column_isin" class="md-nav__link">
    filter_column_isin()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_date" class="md-nav__link">
    filter_date()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_on" class="md-nav__link">
    filter_on()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.filter.filter_string" class="md-nav__link">
    filter_string()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.find_replace" class="md-nav__link">
    find_replace
  </a>
  
    <nav class="md-nav" aria-label="find_replace">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.find_replace.find_replace" class="md-nav__link">
    find_replace()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.flag_nulls" class="md-nav__link">
    flag_nulls
  </a>
  
    <nav class="md-nav" aria-label="flag_nulls">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.flag_nulls.flag_nulls" class="md-nav__link">
    flag_nulls()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.get_dupes" class="md-nav__link">
    get_dupes
  </a>
  
    <nav class="md-nav" aria-label="get_dupes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.get_dupes.get_dupes" class="md-nav__link">
    get_dupes()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.groupby_agg" class="md-nav__link">
    groupby_agg
  </a>
  
    <nav class="md-nav" aria-label="groupby_agg">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.groupby_agg.groupby_agg" class="md-nav__link">
    groupby_agg()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.groupby_topk" class="md-nav__link">
    groupby_topk
  </a>
  
    <nav class="md-nav" aria-label="groupby_topk">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.groupby_topk.groupby_topk" class="md-nav__link">
    groupby_topk()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.impute" class="md-nav__link">
    impute
  </a>
  
    <nav class="md-nav" aria-label="impute">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.impute.impute" class="md-nav__link">
    impute()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.jitter" class="md-nav__link">
    jitter
  </a>
  
    <nav class="md-nav" aria-label="jitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.jitter.jitter" class="md-nav__link">
    jitter()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.join_apply" class="md-nav__link">
    join_apply
  </a>
  
    <nav class="md-nav" aria-label="join_apply">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.join_apply.join_apply" class="md-nav__link">
    join_apply()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.label_encode" class="md-nav__link">
    label_encode
  </a>
  
    <nav class="md-nav" aria-label="label_encode">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.label_encode.label_encode" class="md-nav__link">
    label_encode()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.limit_column_characters" class="md-nav__link">
    limit_column_characters
  </a>
  
    <nav class="md-nav" aria-label="limit_column_characters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.limit_column_characters.limit_column_characters" class="md-nav__link">
    limit_column_characters()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.min_max_scale" class="md-nav__link">
    min_max_scale
  </a>
  
    <nav class="md-nav" aria-label="min_max_scale">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.min_max_scale.min_max_scale" class="md-nav__link">
    min_max_scale()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.move" class="md-nav__link">
    move
  </a>
  
    <nav class="md-nav" aria-label="move">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.move.move" class="md-nav__link">
    move()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.pivot" class="md-nav__link">
    pivot
  </a>
  
    <nav class="md-nav" aria-label="pivot">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.pivot.pivot_longer" class="md-nav__link">
    pivot_longer()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.pivot.pivot_wider" class="md-nav__link">
    pivot_wider()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.process_text" class="md-nav__link">
    process_text
  </a>
  
    <nav class="md-nav" aria-label="process_text">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.process_text.process_text" class="md-nav__link">
    process_text()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.remove_columns" class="md-nav__link">
    remove_columns
  </a>
  
    <nav class="md-nav" aria-label="remove_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.remove_columns.remove_columns" class="md-nav__link">
    remove_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.remove_empty" class="md-nav__link">
    remove_empty
  </a>
  
    <nav class="md-nav" aria-label="remove_empty">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.remove_empty.remove_empty" class="md-nav__link">
    remove_empty()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.rename_columns" class="md-nav__link">
    rename_columns
  </a>
  
    <nav class="md-nav" aria-label="rename_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.rename_columns.rename_column" class="md-nav__link">
    rename_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.rename_columns.rename_columns" class="md-nav__link">
    rename_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.reorder_columns" class="md-nav__link">
    reorder_columns
  </a>
  
    <nav class="md-nav" aria-label="reorder_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.reorder_columns.reorder_columns" class="md-nav__link">
    reorder_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.round_to_fraction" class="md-nav__link">
    round_to_fraction
  </a>
  
    <nav class="md-nav" aria-label="round_to_fraction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.round_to_fraction.round_to_fraction" class="md-nav__link">
    round_to_fraction()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.row_to_names" class="md-nav__link">
    row_to_names
  </a>
  
    <nav class="md-nav" aria-label="row_to_names">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.row_to_names.row_to_names" class="md-nav__link">
    row_to_names()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.select_columns" class="md-nav__link">
    select_columns
  </a>
  
    <nav class="md-nav" aria-label="select_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.select_columns.select_columns" class="md-nav__link">
    select_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.shuffle" class="md-nav__link">
    shuffle
  </a>
  
    <nav class="md-nav" aria-label="shuffle">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.shuffle.shuffle" class="md-nav__link">
    shuffle()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.sort_column_value_order" class="md-nav__link">
    sort_column_value_order
  </a>
  
    <nav class="md-nav" aria-label="sort_column_value_order">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.sort_column_value_order.sort_column_value_order" class="md-nav__link">
    sort_column_value_order()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.sort_naturally" class="md-nav__link">
    sort_naturally
  </a>
  
    <nav class="md-nav" aria-label="sort_naturally">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.sort_naturally.sort_naturally" class="md-nav__link">
    sort_naturally()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.take_first" class="md-nav__link">
    take_first
  </a>
  
    <nav class="md-nav" aria-label="take_first">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.take_first.take_first" class="md-nav__link">
    take_first()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.then" class="md-nav__link">
    then
  </a>
  
    <nav class="md-nav" aria-label="then">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.then.then" class="md-nav__link">
    then()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.to_datetime" class="md-nav__link">
    to_datetime
  </a>
  
    <nav class="md-nav" aria-label="to_datetime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.to_datetime.to_datetime" class="md-nav__link">
    to_datetime()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.toset" class="md-nav__link">
    toset
  </a>
  
    <nav class="md-nav" aria-label="toset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.toset.toset" class="md-nav__link">
    toset()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.transform_columns" class="md-nav__link">
    transform_columns
  </a>
  
    <nav class="md-nav" aria-label="transform_columns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.transform_columns.transform_column" class="md-nav__link">
    transform_column()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.transform_columns.transform_columns" class="md-nav__link">
    transform_columns()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.truncate_datetime" class="md-nav__link">
    truncate_datetime
  </a>
  
    <nav class="md-nav" aria-label="truncate_datetime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.truncate_datetime.truncate_datetime_dataframe" class="md-nav__link">
    truncate_datetime_dataframe()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.update_where" class="md-nav__link">
    update_where
  </a>
  
    <nav class="md-nav" aria-label="update_where">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.update_where.update_where" class="md-nav__link">
    update_where()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#janitor.functions.utils" class="md-nav__link">
    utils
  </a>
  
    <nav class="md-nav" aria-label="utils">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#janitor.functions.utils.patterns" class="md-nav__link">
    patterns()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#janitor.functions.utils.unionize_dataframe_categories" class="md-nav__link">
    unionize_dataframe_categories()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/pyjanitor-devs/pyjanitor/edit/master/docs/api/functions.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="functions">Functions</h1>


  <div class="doc doc-object doc-module">

<a id="janitor.functions"></a>
    <div class="doc doc-contents first">

      <h2 id="janitor.functions--general-functions">General Functions</h2>
<p>pyjanitor's general-purpose data cleaning functions.</p>
<p>NOTE: Instructions for future contributors:</p>
<ol>
<li>Place the source code of the functions in a file named after the function.</li>
<li>Place utility functions in the same file.</li>
<li>If you use a utility function from another source file,
please refactor it out to <code>janitor.functions.utils</code>.</li>
<li>Import the function into this file so that it shows up in the top-level API.</li>
<li>Sort the imports in alphabetical order.</li>
<li>Try to group related functions together (e.g. see <code>convert_date.py</code>)</li>
<li>Never import utils.</li>
</ol>



  <div class="doc doc-children">










  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.add_columns" class="doc doc-heading">
        <code>add_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.add_columns.add_column" class="doc doc-heading">
<code class="highlight language-python">add_column(df, column_name, value, fill_remaining=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Add a column to the dataframe.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Intended to be the method-chaining alternative to::</p>
<pre class="highlight"><code>df[column_name] = value
</code></pre>
<p>Method chaining syntax adding a column with only a single value:</p>
<pre class="highlight"><code># This will add a column with only one value.
df = pd.DataFrame(...).add_column(column_name="new_column", 2)
</code></pre>
<p>Method chaining syntax adding a column with more than one value:</p>
<pre class="highlight"><code># This will add a column with an iterable of values.
vals = [1, 2, 5, ..., 3, 4]  # of same length as the dataframe.
df = pd.DataFrame(...).add_column(column_name="new_column", vals)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>str</code></td>
        <td><p>Name of the new column. Should be a string, in order for the column name to be compatible with the Feather binary format (this is a useful thing to have).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>value</code></td>
        <td><code>Union[List[Any], Tuple[Any], Any]</code></td>
        <td><p>Either a single value, or a list/tuple of values.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fill_remaining</code></td>
        <td><code>bool</code></td>
        <td><p>If value is a tuple or list that is smaller than the number of rows in the DataFrame, repeat the list or tuple (R-style) to the end of the DataFrame.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with an added column.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if attempting to add a column that already exists.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>value</code> has more elements that number of rows in the DataFrame.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if attempting to add an iterable of values with a length not equal to the number of DataFrame rows.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>value</code> has length of `0``.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/add_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(col_name="column_name")
def add_column(
    df: pd.DataFrame,
    column_name: str,
    value: Union[List[Any], Tuple[Any], Any],
    fill_remaining: bool = False,
) -&gt; pd.DataFrame:
    """Add a column to the dataframe.

    This method does not mutate the original DataFrame.

    Intended to be the method-chaining alternative to::

        df[column_name] = value

    Method chaining syntax adding a column with only a single value:



        # This will add a column with only one value.
        df = pd.DataFrame(...).add_column(column_name="new_column", 2)

    Method chaining syntax adding a column with more than one value:



        # This will add a column with an iterable of values.
        vals = [1, 2, 5, ..., 3, 4]  # of same length as the dataframe.
        df = pd.DataFrame(...).add_column(column_name="new_column", vals)

    :param df: A pandas DataFrame.
    :param column_name: Name of the new column. Should be a string, in order
        for the column name to be compatible with the Feather binary
        format (this is a useful thing to have).
    :param value: Either a single value, or a list/tuple of values.
    :param fill_remaining: If value is a tuple or list that is smaller than
        the number of rows in the DataFrame, repeat the list or tuple
        (R-style) to the end of the DataFrame.
    :returns: A pandas DataFrame with an added column.
    :raises ValueError: if attempting to add a column that already exists.
    :raises ValueError: if `value` has more elements that number of
        rows in the DataFrame.
    :raises ValueError: if attempting to add an iterable of values with
        a length not equal to the number of DataFrame rows.
    :raises ValueError: if `value` has length of `0``.
    """
    # TODO: Convert examples to notebook.
    # :Setup:

    # ```python

    #     import pandas as pd
    #     import janitor
    #     data = {
    #         "a": [1, 2, 3] * 3,
    #         "Bell__Chart": [1, 2, 3] * 3,
    #         "decorated-elephant": [1, 2, 3] * 3,
    #         "animals": ["rabbit", "leopard", "lion"] * 3,
    #         "cities": ["Cambridge", "Shanghai", "Basel"] * 3,
    #     }
    #     df = pd.DataFrame(data)

    # :Example 1: Create a new column with a single value:

    # ```python

    #     df.add_column("city_pop", 100000)

    # :Output:

    # ```python

    #        a  Bell__Chart  decorated-elephant  animals     cities  city_pop
    #     0  1            1                   1   rabbit  Cambridge    100000
    #     1  2            2                   2  leopard   Shanghai    100000
    #     2  3            3                   3     lion      Basel    100000
    #     3  1            1                   1   rabbit  Cambridge    100000
    #     4  2            2                   2  leopard   Shanghai    100000
    #     5  3            3                   3     lion      Basel    100000
    #     6  1            1                   1   rabbit  Cambridge    100000
    #     7  2            2                   2  leopard   Shanghai    100000
    #     8  3            3                   3     lion      Basel    100000

    # :Example 2: Create a new column with an iterator which fills to the
    # column
    # size:

    # ```python

    #     df.add_column("city_pop", range(3), fill_remaining=True)

    # :Output:

    # ```python

    #        a  Bell__Chart  decorated-elephant  animals     cities  city_pop
    #     0  1            1                   1   rabbit  Cambridge         0
    #     1  2            2                   2  leopard   Shanghai         1
    #     2  3            3                   3     lion      Basel         2
    #     3  1            1                   1   rabbit  Cambridge         0
    #     4  2            2                   2  leopard   Shanghai         1
    #     5  3            3                   3     lion      Basel         2
    #     6  1            1                   1   rabbit  Cambridge         0
    #     7  2            2                   2  leopard   Shanghai         1
    #     8  3            3                   3     lion      Basel         2

    # :Example 3: Add new column based on mutation of other columns:

    # ```python

    #     df.add_column("city_pop", df.Bell__Chart - 2 * df.a)

    # :Output:

    # ```python

    #        a  Bell__Chart  decorated-elephant  animals     cities  city_pop
    #     0  1            1                   1   rabbit  Cambridge        -1
    #     1  2            2                   2  leopard   Shanghai        -2
    #     2  3            3                   3     lion      Basel        -3
    #     3  1            1                   1   rabbit  Cambridge        -1
    #     4  2            2                   2  leopard   Shanghai        -2
    #     5  3            3                   3     lion      Basel        -3
    #     6  1            1                   1   rabbit  Cambridge        -1
    #     7  2            2                   2  leopard   Shanghai        -2
    #     8  3            3                   3     lion      Basel        -3

    df = df.copy()
    check("column_name", column_name, [str])

    if column_name in df.columns:
        raise ValueError(
            f"Attempted to add column that already exists: " f"{column_name}."
        )

    nrows = df.shape[0]

    if hasattr(value, "__len__") and not isinstance(
        value, (str, bytes, bytearray)
    ):
        # if `value` is a list, ndarray, etc.
        if len(value) &gt; nrows:
            raise ValueError(
                "`value` has more elements than number of rows "
                f"in your `DataFrame`. vals: {len(value)}, "
                f"df: {nrows}"
            )
        if len(value) != nrows and not fill_remaining:
            raise ValueError(
                "Attempted to add iterable of values with length"
                " not equal to number of DataFrame rows"
            )

        if len(value) == 0:
            raise ValueError(
                "`value` has to be an iterable of minimum length 1"
            )
        len_value = len(value)
    elif fill_remaining:
        # relevant if a scalar val was passed, yet fill_remaining == True
        len_value = 1
        value = [value]

    nrows = df.shape[0]

    if fill_remaining:
        times_to_loop = int(np.ceil(nrows / len_value))

        fill_values = list(value) * times_to_loop

        df[column_name] = fill_values[:nrows]
    else:
        df[column_name] = value

    return df
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.add_columns.add_columns" class="doc doc-heading">
<code class="highlight language-python">add_columns(df, fill_remaining=False, **kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Add multiple columns to the dataframe.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Method to augment <code>add_column</code> with ability to add multiple columns in
one go. This replaces the need for multiple <code>add_column</code> calls.</p>
<p>Usage is through supplying kwargs where the key is the col name and the
values correspond to the values of the new DataFrame column.</p>
<p>Values passed can be scalar or iterable (list, ndarray, etc.)</p>
<p>Usage example:</p>
<pre class="highlight"><code>x = 3
y = np.arange(0, 10)
df = pd.DataFrame(...).add_columns(x=x, y=y)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fill_remaining</code></td>
        <td><code>bool</code></td>
        <td><p>If value is a tuple or list that is smaller than the number of rows in the DataFrame, repeat the list or tuple (R-style) to the end of the DataFrame. (Passed to <code>add_column</code>)</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>column, value pairs which are looped through in <code>add_column</code> calls.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with added columns.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/add_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def add_columns(
    df: pd.DataFrame, fill_remaining: bool = False, **kwargs
) -&gt; pd.DataFrame:
    """Add multiple columns to the dataframe.

    This method does not mutate the original DataFrame.

    Method to augment `add_column` with ability to add multiple columns in
    one go. This replaces the need for multiple `add_column` calls.

    Usage is through supplying kwargs where the key is the col name and the
    values correspond to the values of the new DataFrame column.

    Values passed can be scalar or iterable (list, ndarray, etc.)

    Usage example:



        x = 3
        y = np.arange(0, 10)
        df = pd.DataFrame(...).add_columns(x=x, y=y)

    :param df: A pandas dataframe.
    :param fill_remaining: If value is a tuple or list that is smaller than
        the number of rows in the DataFrame, repeat the list or tuple
        (R-style) to the end of the DataFrame. (Passed to `add_column`)
    :param kwargs: column, value pairs which are looped through in
        `add_column` calls.
    :returns: A pandas DataFrame with added columns.
    """
    # Note: error checking can pretty much be handled in `add_column`

    for col_name, values in kwargs.items():
        df = df.add_column(col_name, values, fill_remaining=fill_remaining)

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.also" class="doc doc-heading">
        <code>also</code>



</h2>

    <div class="doc doc-contents ">

      <p>Implementation source for chainable function <code>also</code>.</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.also.also" class="doc doc-heading">
<code class="highlight language-python">also(df, func, *args, **kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Run a function with side effects.</p>
<p>THis function allows you to run an arbitrary function
in the <code>pyjanitor</code> method chain.
Doing so will let you do things like save the dataframe to disk midway
while continuing to modify the dataframe afterwards.</p>
<p>Example usage:</p>
<pre><code class="language-python">df = (
    pd.DataFrame(...)
    .query(...)
    .also(lambda df: print(f&quot;DataFrame shape is: {df.shape}&quot;))
    .transform_column(...)
    .also(lambda df: df.to_csv(&quot;midpoint.csv&quot;))
    .also(
        lambda df: print(
            f&quot;Column col_name has these values: {set(df['col_name'].unique())}&quot;
        )
    )
    .group_add(...)
)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>func</code></td>
        <td><code>Callable</code></td>
        <td><p>A function you would like to run in the method chain. It should take one DataFrame object as a parameter and have no return. If there is a return, it will be ignored.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>args</code></td>
        <td></td>
        <td><p>Optional arguments for <code>func</code>.</p></td>
        <td><code>()</code></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>Optional keyword arguments for <code>func</code>.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>The input pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/also.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def also(df: pd.DataFrame, func: Callable, *args, **kwargs) -&gt; pd.DataFrame:
    """
    Run a function with side effects.

    THis function allows you to run an arbitrary function
    in the `pyjanitor` method chain.
    Doing so will let you do things like save the dataframe to disk midway
    while continuing to modify the dataframe afterwards.

    Example usage:

    ```python
    df = (
        pd.DataFrame(...)
        .query(...)
        .also(lambda df: print(f"DataFrame shape is: {df.shape}"))
        .transform_column(...)
        .also(lambda df: df.to_csv("midpoint.csv"))
        .also(
            lambda df: print(
                f"Column col_name has these values: {set(df['col_name'].unique())}"
            )
        )
        .group_add(...)
    )
    ```

    :param df: A pandas dataframe.
    :param func: A function you would like to run in the method chain.
        It should take one DataFrame object as a parameter and have no return.
        If there is a return, it will be ignored.
    :param args: Optional arguments for `func`.
    :param kwargs: Optional keyword arguments for `func`.
    :returns: The input pandas DataFrame.
    """  # noqa: E501
    func(df.copy(), *args, **kwargs)
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.bin_numeric" class="doc doc-heading">
        <code>bin_numeric</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.bin_numeric.bin_numeric" class="doc doc-heading">
<code class="highlight language-python">bin_numeric(df, from_column_name, to_column_name, num_bins=5, labels=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Generate a new column that labels bins for a specified numeric column.</p>
<p>This method mutates the original DataFrame.</p>
<p>Makes use of pandas <code>cut()</code> function to bin data of one column,
generating a new column with the results.</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    df = (
        pd.DataFrame(...)
        .bin_numeric(
            from_column_name='col1',
            to_column_name='col1_binned',
            num_bins=3,
            labels=['1-2', '3-4', '5-6']
            )
    )
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>from_column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The column whose data you want binned.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>to_column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The new column to be created with the binned data.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>num_bins</code></td>
        <td><code>int</code></td>
        <td><p>The number of bins to be utilized.</p></td>
        <td><code>5</code></td>
      </tr>
      <tr>
        <td><code>labels</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Optionally rename numeric bin ranges with labels. Number of label names must match number of bins specified.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if number of labels do not match number of bins.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/bin_numeric.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(from_column="from_column_name", to_column="to_column_name")
def bin_numeric(
    df: pd.DataFrame,
    from_column_name: Hashable,
    to_column_name: Hashable,
    num_bins: int = 5,
    labels: Optional[str] = None,
) -&gt; pd.DataFrame:
    """
    Generate a new column that labels bins for a specified numeric column.

    This method mutates the original DataFrame.

    Makes use of pandas `cut()` function to bin data of one column,
    generating a new column with the results.

    ```python
        import pandas as pd
        import janitor
        df = (
            pd.DataFrame(...)
            .bin_numeric(
                from_column_name='col1',
                to_column_name='col1_binned',
                num_bins=3,
                labels=['1-2', '3-4', '5-6']
                )
        )
    ```

    :param df: A pandas DataFrame.
    :param from_column_name: The column whose data you want binned.
    :param to_column_name: The new column to be created with the binned data.
    :param num_bins: The number of bins to be utilized.
    :param labels: Optionally rename numeric bin ranges with labels. Number of
        label names must match number of bins specified.
    :return: A pandas DataFrame.
    :raises ValueError: if number of labels do not match number of bins.
    """
    if not labels:
        df[str(to_column_name)] = pd.cut(
            df[str(from_column_name)], bins=num_bins
        )
    else:
        if not len(labels) == num_bins:
            raise ValueError("Number of labels must match number of bins.")

        df[str(to_column_name)] = pd.cut(
            df[str(from_column_name)], bins=num_bins, labels=labels
        )

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.case_when" class="doc doc-heading">
        <code>case_when</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.case_when.case_when" class="doc doc-heading">
<code class="highlight language-python">case_when(df, *args, *, column_name)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Convenience function for creating a column,
based on a condition, or multiple conditions.</p>
<p>It is similar to SQL and dplyr's case_when,
with inspiration from <code>pydatatable</code> if_else function.</p>
<p>If your scenario requires direct replacement of values,
pandas' <code>replace</code> method or <code>map</code> method should be better
suited and more efficient; if the conditions check
if a value is within a range of values, pandas' <code>cut</code> or <code>qcut</code>
should be more efficient; <code>np.where/np.select</code> are also
performant options.</p>
<p>This function relies on <code>pd.Series.mask</code> method.</p>
<p>When multiple conditions are satisfied, the first one is used.</p>
<p>The variable <code>*args</code> parameters takes arguments of the form :
<code>condition0</code>, <code>value0</code>, <code>condition1</code>, <code>value1</code>, ..., <code>default</code>.
If <code>condition0</code> evaluates to <code>True</code>, then assign <code>value0</code> to
<code>column_name</code>, if <code>condition1</code> evaluates to <code>True</code>, then
assign <code>value1</code> to <code>column_name</code>, and so on. If none of the
conditions evaluate to <code>True</code>, assign <code>default</code> to
<code>column_name</code>.</p>
<p>This function can be likened to SQL's <code>case_when</code>:</p>
<pre><code class="language-sql">CASE WHEN condition0 THEN value0
    WHEN condition1 THEN value1
    --- more conditions
    ELSE default
    END AS column_name
</code></pre>
<p>compared to python's <code>if-elif-else</code>:</p>
<pre><code class="language-python">if condition0:
    value0
elif condition1:
    value1
# more elifs
else:
    default
</code></pre>
<p>Functional usage syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

df = pd.DataFrame(...)
right = pd.DataFrame(...)

df = jn.case_when(
    df,
    condition0, result0,
    condition1, result1,
    ...,
    default,
    column_name = 'column',
)
</code></pre>
<p>Method chaining syntax:</p>
<p>.. code-block:: python</p>
<pre><code class="language-python">df = df.case_when(
    condition0, result0,
    condition1, result1,
    ...,
    default,
    column_name = 'column',
)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A Pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>args</code></td>
        <td></td>
        <td><p>Variable argument of conditions and expected values. Takes the form <code>condition0</code>, <code>value0</code>, <code>condition1</code>, <code>value1</code>, ..., <code>default</code>. <code>condition</code> can be a 1-D boolean array, a callable, or a string. If <code>condition</code> is a callable, it should evaluate to a 1-D boolean array. The array should have the same length as the DataFrame. If it is a string, it is computed on the dataframe, via <code>df.eval</code>, and should return a 1-D boolean array. <code>result</code> can be a scalar, a 1-D array, or a callable. If <code>result</code> is a callable, it should evaluate to a 1-D array. For a 1-D array, it should have the same length as the DataFrame. The <code>default</code> argument applies if none of <code>condition0</code>, <code>condition1</code>, ..., evaluates to <code>True</code>. Value can be a scalar, a callabe, or a 1-D array. if <code>default</code> is a callable, it should evaluate to a 1-D array. The 1-D array should be the same length as the DataFrame.</p></td>
        <td><code>()</code></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>str</code></td>
        <td><p>Name of column to assign results to. A new column is created, if it does not already exist in the DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if the condition fails to evaluate.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/case_when.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def case_when(df: pd.DataFrame, *args, column_name: str) -&gt; pd.DataFrame:
    """
    Convenience function for creating a column,
    based on a condition, or multiple conditions.

    It is similar to SQL and dplyr's case_when,
    with inspiration from `pydatatable` if_else function.

    If your scenario requires direct replacement of values,
    pandas' `replace` method or `map` method should be better
    suited and more efficient; if the conditions check
    if a value is within a range of values, pandas' `cut` or `qcut`
    should be more efficient; `np.where/np.select` are also
    performant options.

    This function relies on `pd.Series.mask` method.

    When multiple conditions are satisfied, the first one is used.

    The variable `*args` parameters takes arguments of the form :
    `condition0`, `value0`, `condition1`, `value1`, ..., `default`.
    If `condition0` evaluates to `True`, then assign `value0` to
    `column_name`, if `condition1` evaluates to `True`, then
    assign `value1` to `column_name`, and so on. If none of the
    conditions evaluate to `True`, assign `default` to
    `column_name`.

    This function can be likened to SQL's `case_when`:

    ```sql
    CASE WHEN condition0 THEN value0
        WHEN condition1 THEN value1
        --- more conditions
        ELSE default
        END AS column_name
    ```

    compared to python's `if-elif-else`:

    ```python
    if condition0:
        value0
    elif condition1:
        value1
    # more elifs
    else:
        default
    ```

    Functional usage syntax:

    ```python
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)
    right = pd.DataFrame(...)

    df = jn.case_when(
        df,
        condition0, result0,
        condition1, result1,
        ...,
        default,
        column_name = 'column',
    )
    ```

    Method chaining syntax:

    .. code-block:: python

    ```python
    df = df.case_when(
        condition0, result0,
        condition1, result1,
        ...,
        default,
        column_name = 'column',
    )
    ```

    :param df: A Pandas dataframe.
    :param args: Variable argument of conditions and expected values.
        Takes the form
        `condition0`, `value0`, `condition1`, `value1`, ..., `default`.
        `condition` can be a 1-D boolean array, a callable, or a string.
        If `condition` is a callable, it should evaluate
        to a 1-D boolean array. The array should have the same length
        as the DataFrame. If it is a string, it is computed on the dataframe,
        via `df.eval`, and should return a 1-D boolean array.
        `result` can be a scalar, a 1-D array, or a callable.
        If `result` is a callable, it should evaluate to a 1-D array.
        For a 1-D array, it should have the same length as the DataFrame.
        The `default` argument applies if none of `condition0`,
        `condition1`, ..., evaluates to `True`.
        Value can be a scalar, a callabe, or a 1-D array. if `default` is a
        callable, it should evaluate to a 1-D array.
        The 1-D array should be the same length as the DataFrame.
    :param column_name: Name of column to assign results to. A new column
        is created, if it does not already exist in the DataFrame.
    :raises ValueError: if the condition fails to evaluate.
    :returns: A pandas DataFrame.
    """
    conditions, targets, default = _case_when_checks(df, args, column_name)

    if len(conditions) == 1:
        default = default.mask(conditions[0], targets[0])
        return df.assign(**{column_name: default})

    # ensures value assignment is on a first come basis
    conditions = conditions[::-1]
    targets = targets[::-1]
    for condition, value, index in zip(conditions, targets, count()):
        try:
            default = default.mask(condition, value)
        # error `feedoff` idea from SO
        # https://stackoverflow.com/a/46091127/7175713
        except Exception as e:
            raise ValueError(
                f"""
                condition{index} and value{index}
                failed to evaluate.
                Original error message: {e}
                """
            ) from e

    return df.assign(**{column_name: default})
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.change_type" class="doc doc-heading">
        <code>change_type</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.change_type.change_type" class="doc doc-heading">
<code class="highlight language-python">change_type(df, column_name, dtype, ignore_exception=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Change the type of a column.</p>
<p>This method mutates the original DataFrame.</p>
<p>Exceptions that are raised can be ignored. For example, if one has a mixed
dtype column that has non-integer strings and integers, and you want to
coerce everything to integers, you can optionally ignore the non-integer
strings and replace them with <code>NaN</code> or keep the original value</p>
<p>Intended to be the method-chaining alternative to:</p>
<pre><code class="language-python">df[col] = df[col].astype(dtype)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">df = pd.DataFrame(...).change_type('col1', str)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>A column in the dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dtype</code></td>
        <td><code>type</code></td>
        <td><p>The datatype to convert to. Should be one of the standard Python types, or a numpy datatype.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ignore_exception</code></td>
        <td><code>bool</code></td>
        <td><p>one of `{False, "fillna", "keep_values"}``.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with changed column types.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if unknown option provided for `ignore_exception``.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/change_type.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def change_type(
    df: pd.DataFrame,
    column_name: Hashable,
    dtype: type,
    ignore_exception: bool = False,
) -&gt; pd.DataFrame:
    """Change the type of a column.

    This method mutates the original DataFrame.

    Exceptions that are raised can be ignored. For example, if one has a mixed
    dtype column that has non-integer strings and integers, and you want to
    coerce everything to integers, you can optionally ignore the non-integer
    strings and replace them with `NaN` or keep the original value

    Intended to be the method-chaining alternative to:


    ```python
    df[col] = df[col].astype(dtype)
    ```

    Method chaining syntax:

    ```python
    df = pd.DataFrame(...).change_type('col1', str)
    ```

    :param df: A pandas dataframe.
    :param column_name: A column in the dataframe.
    :param dtype: The datatype to convert to. Should be one of the standard
        Python types, or a numpy datatype.
    :param ignore_exception: one of `{False, "fillna", "keep_values"}``.
    :returns: A pandas DataFrame with changed column types.
    :raises ValueError: if unknown option provided for
        `ignore_exception``.
    """
    if not ignore_exception:
        df[column_name] = df[column_name].astype(dtype)
    elif ignore_exception == "keep_values":
        df[column_name] = df[column_name].astype(dtype, errors="ignore")
    elif ignore_exception == "fillna":
        # returns None when conversion
        def convert(x, dtype):
            try:
                return dtype(x)
            except ValueError:
                return None

        df[column_name] = df[column_name].apply(lambda x: convert(x, dtype))
    else:
        raise ValueError("unknown option for ignore_exception")
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.clean_names" class="doc doc-heading">
        <code>clean_names</code>



</h2>

    <div class="doc doc-contents ">

      <p>Functions for cleaning columns names.</p>



  <div class="doc doc-children">









  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.clean_names.clean_names" class="doc doc-heading">
<code class="highlight language-python">clean_names(df, strip_underscores=None, case_type='lower', remove_special=False, strip_accents=True, preserve_original_columns=True, enforce_string=True, truncate_limit=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Clean column names.</p>
<p>Takes all column names, converts them to lowercase,
then replaces all spaces with underscores.</p>
<p>By default, column names are converted to string types.
This can be switched off by passing in <code>enforce_string=False</code>.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = clean_names(df)
</code></pre>
<p>Method chaining syntax:</p>
<p>```python
import pandas as pd
import janitor
df = pd.DataFrame(...).clean_names()</p>
<p>Examples of transformation:</p>
<ul>
<li>Columns before: First Name, Last Name, Employee Status, Subject</li>
<li>Columns after: first_name, last_name, employee_status, subject</li>
</ul>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>strip_underscores</code></td>
        <td><code>Union[str, bool]</code></td>
        <td><p>(optional) Removes the outer underscores from all column names. Default None keeps outer underscores. Values can be either 'left', 'right' or 'both' or the respective shorthand 'l', 'r' and True.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>case_type</code></td>
        <td><code>str</code></td>
        <td><p>(optional) Whether to make columns lower or uppercase. Current case may be preserved with 'preserve', while snake case conversion (from CamelCase or camelCase only) can be turned on using "snake". Default 'lower' makes all characters lowercase.</p></td>
        <td><code>&#39;lower&#39;</code></td>
      </tr>
      <tr>
        <td><code>remove_special</code></td>
        <td><code>bool</code></td>
        <td><p>(optional) Remove special characters from columns. Only letters, numbers and underscores are preserved.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>strip_accents</code></td>
        <td><code>bool</code></td>
        <td><p>Whether or not to remove accents from columns names.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>preserve_original_columns</code></td>
        <td><code>bool</code></td>
        <td><p>(optional) Preserve original names. This is later retrievable using <code>df.original_columns</code>.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>enforce_string</code></td>
        <td><code>bool</code></td>
        <td><p>Whether or not to convert all column names to string type. Defaults to True, but can be turned off. Columns with &gt;1 levels will not be converted by default.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>truncate_limit</code></td>
        <td><code>int</code></td>
        <td><p>(optional) Truncates formatted column names to the specified length. Default None does not truncate.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/clean_names.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def clean_names(
    df: pd.DataFrame,
    strip_underscores: Optional[Union[str, bool]] = None,
    case_type: str = "lower",
    remove_special: bool = False,
    strip_accents: bool = True,
    preserve_original_columns: bool = True,
    enforce_string: bool = True,
    truncate_limit: int = None,
) -&gt; pd.DataFrame:
    """
    Clean column names.

    Takes all column names, converts them to lowercase,
    then replaces all spaces with underscores.

    By default, column names are converted to string types.
    This can be switched off by passing in `enforce_string=False`.

    This method does not mutate the original DataFrame.

    Functional usage syntax:

    ```python
    df = clean_names(df)
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    df = pd.DataFrame(...).clean_names()

    Examples of transformation:

    - Columns before: First Name, Last Name, Employee Status, Subject
    - Columns after: first_name, last_name, employee_status, subject

    :param df: The pandas DataFrame object.
    :param strip_underscores: (optional) Removes the outer underscores from all
        column names. Default None keeps outer underscores. Values can be
        either 'left', 'right' or 'both' or the respective shorthand 'l', 'r'
        and True.
    :param case_type: (optional) Whether to make columns lower or uppercase.
        Current case may be preserved with 'preserve',
        while snake case conversion (from CamelCase or camelCase only)
        can be turned on using "snake".
        Default 'lower' makes all characters lowercase.
    :param remove_special: (optional) Remove special characters from columns.
        Only letters, numbers and underscores are preserved.
    :param strip_accents: Whether or not to remove accents from
        columns names.
    :param preserve_original_columns: (optional) Preserve original names.
        This is later retrievable using `df.original_columns`.
    :param enforce_string: Whether or not to convert all column names
        to string type. Defaults to True, but can be turned off.
        Columns with &gt;1 levels will not be converted by default.
    :param truncate_limit: (optional) Truncates formatted column names to
        the specified length. Default None does not truncate.
    :returns: A pandas DataFrame.
    """
    original_column_names = list(df.columns)

    if enforce_string:
        df = df.rename(columns=str)

    df = df.rename(columns=lambda x: _change_case(x, case_type))

    df = df.rename(columns=_normalize_1)

    if remove_special:
        df = df.rename(columns=_remove_special)

    if strip_accents:
        df = df.rename(columns=_strip_accents)

    df = df.rename(columns=lambda x: re.sub("_+", "_", x))  # noqa: PD005
    df = _strip_underscores(df, strip_underscores)

    df = df.rename(columns=lambda x: x[:truncate_limit])

    # Store the original column names, if enabled by user
    if preserve_original_columns:
        df.__dict__["original_columns"] = original_column_names
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.coalesce" class="doc doc-heading">
        <code>coalesce</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.coalesce.coalesce" class="doc doc-heading">
<code class="highlight language-python">coalesce(df, *column_names, *, target_column_name=None, default_value=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Coalesce two or more columns of data in order of column names provided.</p>
<p>This finds the first non-missing value at each position.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>TODO: Turn the example in this docstring into a Jupyter notebook.</p>
<p>Example:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = pd.DataFrame({&quot;A&quot;: [1, 2, np.nan],
                       &quot;B&quot;: [np.nan, 10, np.nan],
                       &quot;C&quot;: [5, 10, 7]})

         A     B   C
    0  1.0   NaN   5
    1  2.0  10.0  10
    2  NaN   NaN   7

    df.coalesce('A', 'B', 'C',
                target_column_name = 'D')

        A     B   C    D
    0  1.0   NaN   5  1.0
    1  2.0  10.0  10  2.0
    2  NaN   NaN   7  7.0
</code></pre>
<p>If no target column is provided, then the first column is updated,
with the null values removed:</p>
<pre><code class="language-python">    df.coalesce('A', 'B', 'C')

        A     B   C
    0  1.0   NaN   5
    1  2.0  10.0  10
    2  7.0   NaN   7
</code></pre>
<p>If nulls remain, you can fill it with the <code>default_value</code>:</p>
<pre><code class="language-python">    df = pd.DataFrame({'s1':[np.nan,np.nan,6,9,9],
                       's2':[np.nan,8,7,9,9]})

        s1   s2
    0  NaN  NaN
    1  NaN  8.0
    2  6.0  7.0
    3  9.0  9.0
    4  9.0  9.0

    df.coalesce('s1', 's2',
                target_column_name = 's3',
                default_value = 0)

        s1   s2   s3
    0  NaN  NaN  0.0
    1  NaN  8.0  8.0
    2  6.0  7.0  6.0
    3  9.0  9.0  9.0
    4  9.0  9.0  9.0
</code></pre>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = coalesce(df, 'col1', 'col2', target_column_name ='col3')
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    df = pd.DataFrame(...).coalesce('col1', 'col2')
</code></pre>
<p>The first example will create a new column called <code>col3</code> with values from
<code>col2</code> inserted where values from <code>col1</code> are <code>NaN</code>.
The second example will update the values of <code>col1</code>,
since it is the first column in <code>column_names</code>.</p>
<p>This is more syntactic diabetes! For R users, this should look familiar to
<code>dplyr</code>'s <code>coalesce</code> function; for Python users, the interface
should be more intuitive than the <code>pandas.Series.combine_first</code>
method.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td></td>
        <td><p>A list of column names.</p></td>
        <td><code>()</code></td>
      </tr>
      <tr>
        <td><code>target_column_name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The new column name after combining. If <code>None</code>, then the first column in <code>column_names</code> is updated, with the Null values replaced.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>default_value</code></td>
        <td><code>Union[int, float, str]</code></td>
        <td><p>A scalar to replace any remaining nulls after coalescing.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with coalesced columns.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if length of <code>column_names</code> is less than 2.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/coalesce.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names", new_column_name="target_column_name")
def coalesce(
    df: pd.DataFrame,
    *column_names,
    target_column_name: Optional[str] = None,
    default_value: Optional[Union[int, float, str]] = None,
) -&gt; pd.DataFrame:
    """
    Coalesce two or more columns of data in order of column names provided.

    This finds the first non-missing value at each position.

    This method does not mutate the original DataFrame.

    TODO: Turn the example in this docstring into a Jupyter notebook.

    Example:

    ```python
        import pandas as pd
        import janitor as jn

        df = pd.DataFrame({"A": [1, 2, np.nan],
                           "B": [np.nan, 10, np.nan],
                           "C": [5, 10, 7]})

             A     B   C
        0  1.0   NaN   5
        1  2.0  10.0  10
        2  NaN   NaN   7

        df.coalesce('A', 'B', 'C',
                    target_column_name = 'D')

            A     B   C    D
        0  1.0   NaN   5  1.0
        1  2.0  10.0  10  2.0
        2  NaN   NaN   7  7.0
    ```

    If no target column is provided, then the first column is updated,
    with the null values removed:

    ```python
        df.coalesce('A', 'B', 'C')

            A     B   C
        0  1.0   NaN   5
        1  2.0  10.0  10
        2  7.0   NaN   7
    ```

    If nulls remain, you can fill it with the `default_value`:

    ```python
        df = pd.DataFrame({'s1':[np.nan,np.nan,6,9,9],
                           's2':[np.nan,8,7,9,9]})

            s1   s2
        0  NaN  NaN
        1  NaN  8.0
        2  6.0  7.0
        3  9.0  9.0
        4  9.0  9.0

        df.coalesce('s1', 's2',
                    target_column_name = 's3',
                    default_value = 0)

            s1   s2   s3
        0  NaN  NaN  0.0
        1  NaN  8.0  8.0
        2  6.0  7.0  6.0
        3  9.0  9.0  9.0
        4  9.0  9.0  9.0
    ```


    Functional usage syntax:

    ```python
        df = coalesce(df, 'col1', 'col2', target_column_name ='col3')
    ```

    Method chaining syntax:

    ```python
        import pandas as pd
        import janitor
        df = pd.DataFrame(...).coalesce('col1', 'col2')
    ```

    The first example will create a new column called `col3` with values from
    `col2` inserted where values from `col1` are `NaN`.
    The second example will update the values of `col1`,
    since it is the first column in `column_names`.

    This is more syntactic diabetes! For R users, this should look familiar to
    `dplyr`'s `coalesce` function; for Python users, the interface
    should be more intuitive than the `pandas.Series.combine_first`
    method.

    :param df: A pandas DataFrame.
    :param column_names: A list of column names.
    :param target_column_name: The new column name after combining.
        If `None`, then the first column in `column_names` is updated,
        with the Null values replaced.
    :param default_value: A scalar to replace any remaining nulls
        after coalescing.
    :returns: A pandas DataFrame with coalesced columns.
    :raises ValueError: if length of `column_names` is less than 2.
    """

    if not column_names:
        return df

    if len(column_names) &lt; 2:
        raise ValueError(
            """
            The number of columns to coalesce
            should be a minimum of 2.
            """
        )

    column_names = [*column_names]

    column_names = _select_column_names(column_names, df)
    if target_column_name:
        check("target_column_name", target_column_name, [str])
    if default_value:
        check("default_value", default_value, [int, float, str])

    if target_column_name is None:
        target_column_name = column_names[0]
    # bfill/ffill combo is faster than combine_first
    outcome = (
        df.filter(column_names)
        .bfill(axis="columns")
        .ffill(axis="columns")
        .iloc[:, 0]
    )
    if outcome.hasnans and (default_value is not None):
        outcome = outcome.fillna(default_value)
    return df.assign(**{target_column_name: outcome})
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.collapse_levels" class="doc doc-heading">
        <code>collapse_levels</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.collapse_levels.collapse_levels" class="doc doc-heading">
<code class="highlight language-python">collapse_levels(df, sep='_')</code>


</h3>

    <div class="doc doc-contents ">

      <p>Flatten multi-level column dataframe to a single level.</p>
<p>This method mutates the original DataFrame.</p>
<p>Given a <code>DataFrame</code> containing multi-level columns, flatten to single-
level by string-joining the column labels in each level.</p>
<p>After a <code>groupby</code> / <code>aggregate</code> operation where <code>.agg()</code> is passed a
list of multiple aggregation functions, a multi-level DataFrame is
returned with the name of the function applied in the second level.</p>
<p>It is sometimes convenient for later indexing to flatten out this
multi-level configuration back into a single level. This function does
this through a simple string-joining of all the names across different
levels in a single column.</p>
<p>Method chaining syntax given two value columns <code>[max_speed, type]</code>:</p>
<pre><code class="language-python">    data = {&quot;class&quot;: [&quot;bird&quot;, &quot;bird&quot;, &quot;bird&quot;, &quot;mammal&quot;, &quot;mammal&quot;],
            &quot;max_speed&quot;: [389, 389, 24, 80, 21],
            &quot;type&quot;: [&quot;falcon&quot;, &quot;falcon&quot;, &quot;parrot&quot;, &quot;Lion&quot;, &quot;Monkey&quot;]}

    df = (
        pd.DataFrame(data)
            .groupby('class')
            .agg(['mean', 'median'])
            .collapse_levels(sep='_')
    )
</code></pre>
<p>Before applying <code>.collapse_levels</code>, the <code>.agg</code> operation returns a
multi-level column DataFrame whose columns are <code>(level 1, level 2)</code>:</p>
<pre class="highlight"><code>[('class', ''), ('max_speed', 'mean'), ('max_speed', 'median'),
('type', 'mean'), ('type', 'median')]
</code></pre>
<p><code>.collapse_levels</code> then flattens the column names to:</p>
<pre class="highlight"><code>['class', 'max_speed_mean', 'max_speed_median',
'type_mean', 'type_median']


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sep</code></td>
        <td><code>str</code></td>
        <td><p>String separator used to join the column level names</p></td>
        <td><code>&#39;_&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A flattened pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/collapse_levels.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def collapse_levels(df: pd.DataFrame, sep: str = "_") -&gt; pd.DataFrame:
    """
    Flatten multi-level column dataframe to a single level.

    This method mutates the original DataFrame.

    Given a `DataFrame` containing multi-level columns, flatten to single-
    level by string-joining the column labels in each level.

    After a `groupby` / `aggregate` operation where `.agg()` is passed a
    list of multiple aggregation functions, a multi-level DataFrame is
    returned with the name of the function applied in the second level.

    It is sometimes convenient for later indexing to flatten out this
    multi-level configuration back into a single level. This function does
    this through a simple string-joining of all the names across different
    levels in a single column.

    Method chaining syntax given two value columns `[max_speed, type]`:

    ```python
        data = {"class": ["bird", "bird", "bird", "mammal", "mammal"],
                "max_speed": [389, 389, 24, 80, 21],
                "type": ["falcon", "falcon", "parrot", "Lion", "Monkey"]}

        df = (
            pd.DataFrame(data)
                .groupby('class')
                .agg(['mean', 'median'])
                .collapse_levels(sep='_')
        )
    ```

    Before applying `.collapse_levels`, the `.agg` operation returns a
    multi-level column DataFrame whose columns are `(level 1, level 2)`:


        [('class', ''), ('max_speed', 'mean'), ('max_speed', 'median'),
        ('type', 'mean'), ('type', 'median')]

    `.collapse_levels` then flattens the column names to:


        ['class', 'max_speed_mean', 'max_speed_median',
        'type_mean', 'type_median']

    :param df: A pandas DataFrame.
    :param sep: String separator used to join the column level names
    :returns: A flattened pandas DataFrame.
    """
    check("sep", sep, [str])

    # if already single-level, just return the DataFrame
    if not isinstance(df.columns, pd.MultiIndex):
        return df

    df.columns = [
        sep.join(str(el) for el in tup if str(el) != "")
        for tup in df  # noqa: PD011
    ]

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.complete" class="doc doc-heading">
        <code>complete</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.complete.complete" class="doc doc-heading">
<code class="highlight language-python">complete(df, *columns, *, sort=False, by=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>It is modeled after tidyr's <code>complete</code> function, and is a wrapper around
<code>expand_grid</code> and <code>pd.merge</code>.</p>
<p>Combinations of column names or a list/tuple of column names, or even a
dictionary of column names and new values are possible.</p>
<p>It can also handle duplicated data.</p>
<p>MultiIndex columns are not supported.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)

    df = jn.complete(
        df = df,
        column_label,
        (column1, column2, ...),
        {column1: new_values, ...},
        by = label/list_of_labels
    )
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">
    df = (
        pd.DataFrame(...)
        .complete(
            column_label,
            (column1, column2, ...),
            {column1: new_values, ...},
            by = label/list_of_labels
        )
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>*columns</code></td>
        <td></td>
        <td><p>This refers to the columns to be completed. It could be column labels (string type), a list/tuple of column labels, or a dictionary that pairs column labels with new values.</p></td>
        <td><code>()</code></td>
      </tr>
      <tr>
        <td><code>sort</code></td>
        <td><code>bool</code></td>
        <td><p>Sort DataFrame based on *columns. Default is <code>False</code>.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>by</code></td>
        <td><code>Union[list, str]</code></td>
        <td><p>label or list of labels to group by. The explicit missing rows are returned per group.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with explicit missing rows, if any.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/complete.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def complete(
    df: pd.DataFrame,
    *columns,
    sort: bool = False,
    by: Optional[Union[list, str]] = None,
) -&gt; pd.DataFrame:
    """
    It is modeled after tidyr's `complete` function, and is a wrapper around
    `expand_grid` and `pd.merge`.

    Combinations of column names or a list/tuple of column names, or even a
    dictionary of column names and new values are possible.

    It can also handle duplicated data.

    MultiIndex columns are not supported.

    Functional usage syntax:

    ```python

        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)

        df = jn.complete(
            df = df,
            column_label,
            (column1, column2, ...),
            {column1: new_values, ...},
            by = label/list_of_labels
        )
    ```

    Method chaining syntax:

    ```python

        df = (
            pd.DataFrame(...)
            .complete(
                column_label,
                (column1, column2, ...),
                {column1: new_values, ...},
                by = label/list_of_labels
            )
    ```

    :param df: A pandas dataframe.
    :param *columns: This refers to the columns to be
        completed. It could be column labels (string type),
        a list/tuple of column labels, or a dictionary that pairs
        column labels with new values.
    :param sort: Sort DataFrame based on *columns. Default is `False`.
    :param by: label or list of labels to group by.
        The explicit missing rows are returned per group.
    :returns: A pandas DataFrame with explicit missing rows, if any.
    """

    if not columns:
        return df

    df = df.copy()

    return _computations_complete(df, columns, sort, by)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.concatenate_columns" class="doc doc-heading">
        <code>concatenate_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.concatenate_columns.concatenate_columns" class="doc doc-heading">
<code class="highlight language-python">concatenate_columns(df, column_names, new_column_name, sep='-', ignore_empty=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Concatenates the set of columns into a single column.</p>
<p>Used to quickly generate an index based on a group of columns.</p>
<p>This method mutates the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre class="highlight"><code>df = concatenate_columns(df,
                         column_names=['col1', 'col2'],
                         new_column_name='id',
                         sep='-')
</code></pre>
<p>Method chaining syntax:</p>
<pre class="highlight"><code>df = (pd.DataFrame(...).
      concatenate_columns(column_names=['col1', 'col2'],
                          new_column_name='id',
                          sep='-'))


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>List[Hashable]</code></td>
        <td><p>A list of columns to concatenate together.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>new_column_name</code></td>
        <td></td>
        <td><p>The name of the new column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sep</code></td>
        <td><code>str</code></td>
        <td><p>The separator between each column's data.</p></td>
        <td><code>&#39;-&#39;</code></td>
      </tr>
      <tr>
        <td><code>ignore_empty</code></td>
        <td><code>bool</code></td>
        <td><p>Ignore null values if exists.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with concatenated columns.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>JanitorError</code></td>
        <td><p>if at least two columns are not provided within `column_names``.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/concatenate_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names")
def concatenate_columns(
    df: pd.DataFrame,
    column_names: List[Hashable],
    new_column_name,
    sep: str = "-",
    ignore_empty: bool = True,
) -&gt; pd.DataFrame:
    """Concatenates the set of columns into a single column.

    Used to quickly generate an index based on a group of columns.

    This method mutates the original DataFrame.

    Functional usage syntax:

        df = concatenate_columns(df,
                                 column_names=['col1', 'col2'],
                                 new_column_name='id',
                                 sep='-')

    Method chaining syntax:

        df = (pd.DataFrame(...).
              concatenate_columns(column_names=['col1', 'col2'],
                                  new_column_name='id',
                                  sep='-'))

    :param df: A pandas DataFrame.
    :param column_names: A list of columns to concatenate together.
    :param new_column_name: The name of the new column.
    :param sep: The separator between each column's data.
    :param ignore_empty: Ignore null values if exists.
    :returns: A pandas DataFrame with concatenated columns.
    :raises JanitorError: if at least two columns are not provided
        within `column_names``.
    """
    if len(column_names) &lt; 2:
        raise JanitorError("At least two columns must be specified")

    df[new_column_name] = (
        df[column_names].fillna("").astype(str).agg(sep.join, axis=1)
    )

    if ignore_empty:

        def remove_empty_string(x):
            return sep.join(x for x in x.split(sep) if x)

        df[new_column_name] = df[new_column_name].transform(
            remove_empty_string
        )

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.conditional_join" class="doc doc-heading">
        <code>conditional_join</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">











  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.conditional_join.conditional_join" class="doc doc-heading">
<code class="highlight language-python">conditional_join(df, right, *conditions, *, how='inner', sort_by_appearance=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>This is a convenience function that operates similarly to <code>pd.merge</code>,
but allows joins on inequality operators,
or a combination of equi and non-equi joins.</p>
<p>If the join is solely on equality, <code>pd.merge</code> function
is more efficient and should be used instead.</p>
<p>If you are interested in nearest joins, or rolling joins,
<code>pd.merge_asof</code> covers that. There is also the IntervalIndex,
which is usually more efficient for range joins, especially if
the intervals do not overlap.</p>
<p>This function returns rows, if any, where values from <code>df</code> meet the
condition(s) for values from <code>right</code>. The conditions are passed in
as a variable argument of tuples, where the tuple is of
the form <code>(left_on, right_on, op)</code>; <code>left_on</code> is the column
label from <code>df</code>, <code>right_on</code> is the column label from <code>right</code>,
while <code>op</code> is the operator.</p>
<p>The operator can be any of <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code>.</p>
<p>A binary search is used to get the relevant rows for non-equi joins;
this avoids a cartesian join, and makes the process less memory intensive.</p>
<p>For equi-joins, Pandas internal merge function (a hash join) is used.</p>
<p>The join is done only on the columns.
MultiIndex columns are not supported.</p>
<p>For non-equi joins, only numeric and date columns are supported.</p>
<p>Only <code>inner</code>, <code>left</code>, and <code>right</code> joins are supported.</p>
<p>If the columns from <code>df</code> and <code>right</code> have nothing in common,
a single index column is returned; else, a MultiIndex column
is returned.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)
    right = pd.DataFrame(...)

    df = jn.conditional_join(
            df,
            right,
            (col_from_df, col_from_right, join_operator),
            (col_from_df, col_from_right, join_operator),
            ...,
            how = 'inner' # or left/right
            sort_by_appearance = True # or False
            )
</code></pre>
<p>Method chaining syntax:</p>
<p>.. code-block:: python</p>
<pre class="highlight"><code>df.conditional_join(
    right,
    (col_from_df, col_from_right, join_operator),
    (col_from_df, col_from_right, join_operator),
    ...,
    how = 'inner' # or left/right
    sort_by_appearance = True # or False
    )


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A Pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>right</code></td>
        <td><code>Union[pandas.core.frame.DataFrame, pandas.core.series.Series]</code></td>
        <td><p>Named Series or DataFrame to join to.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>conditions</code></td>
        <td></td>
        <td><p>Variable argument of tuple(s) of the form <code>(left_on, right_on, op)</code>, where <code>left_on</code> is the column label from <code>df</code>, <code>right_on</code> is the column label from <code>right</code>, while <code>op</code> is the operator. The operator can be any of <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code>.</p></td>
        <td><code>()</code></td>
      </tr>
      <tr>
        <td><code>how</code></td>
        <td><code>str</code></td>
        <td><p>Indicates the type of join to be performed. It can be one of <code>inner</code>, <code>left</code>, <code>right</code>. Full join is not supported. Defaults to <code>inner</code>.</p></td>
        <td><code>&#39;inner&#39;</code></td>
      </tr>
      <tr>
        <td><code>sort_by_appearance</code></td>
        <td><code>bool</code></td>
        <td><p>Default is <code>False</code>. If True, values from <code>right</code> that meet the join condition will be returned in the final dataframe in the same order that they were before the join.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame of the two merged Pandas objects.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/conditional_join.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def conditional_join(
    df: pd.DataFrame,
    right: Union[pd.DataFrame, pd.Series],
    *conditions,
    how: str = "inner",
    sort_by_appearance: bool = False,
) -&gt; pd.DataFrame:
    """

    This is a convenience function that operates similarly to ``pd.merge``,
    but allows joins on inequality operators,
    or a combination of equi and non-equi joins.

    If the join is solely on equality, `pd.merge` function
    is more efficient and should be used instead.

    If you are interested in nearest joins, or rolling joins,
    `pd.merge_asof` covers that. There is also the IntervalIndex,
    which is usually more efficient for range joins, especially if
    the intervals do not overlap.

    This function returns rows, if any, where values from `df` meet the
    condition(s) for values from `right`. The conditions are passed in
    as a variable argument of tuples, where the tuple is of
    the form `(left_on, right_on, op)`; `left_on` is the column
    label from `df`, `right_on` is the column label from `right`,
    while `op` is the operator.

    The operator can be any of `==`, `!=`, `&lt;=`, `&lt;`, `&gt;=`, `&gt;`.

    A binary search is used to get the relevant rows for non-equi joins;
    this avoids a cartesian join, and makes the process less memory intensive.

    For equi-joins, Pandas internal merge function (a hash join) is used.

    The join is done only on the columns.
    MultiIndex columns are not supported.

    For non-equi joins, only numeric and date columns are supported.

    Only `inner`, `left`, and `right` joins are supported.

    If the columns from `df` and `right` have nothing in common,
    a single index column is returned; else, a MultiIndex column
    is returned.

    Functional usage syntax:

    ```python
        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)
        right = pd.DataFrame(...)

        df = jn.conditional_join(
                df,
                right,
                (col_from_df, col_from_right, join_operator),
                (col_from_df, col_from_right, join_operator),
                ...,
                how = 'inner' # or left/right
                sort_by_appearance = True # or False
                )
    ```

    Method chaining syntax:

    .. code-block:: python

        df.conditional_join(
            right,
            (col_from_df, col_from_right, join_operator),
            (col_from_df, col_from_right, join_operator),
            ...,
            how = 'inner' # or left/right
            sort_by_appearance = True # or False
            )


    :param df: A Pandas DataFrame.
    :param right: Named Series or DataFrame to join to.
    :param conditions: Variable argument of tuple(s) of the form
        `(left_on, right_on, op)`, where `left_on` is the column
        label from `df`, `right_on` is the column label from `right`,
        while `op` is the operator. The operator can be any of
        `==`, `!=`, `&lt;=`, `&lt;`, `&gt;=`, `&gt;`.
    :param how: Indicates the type of join to be performed.
        It can be one of `inner`, `left`, `right`.
        Full join is not supported. Defaults to `inner`.
    :param sort_by_appearance: Default is `False`. If True,
        values from `right` that meet the join condition will be returned
        in the final dataframe in the same order
        that they were before the join.
    :returns: A pandas DataFrame of the two merged Pandas objects.
    """

    return _conditional_join_compute(
        df, right, conditions, how, sort_by_appearance
    )
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.convert_date" class="doc doc-heading">
        <code>convert_date</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.convert_date.convert_excel_date" class="doc doc-heading">
<code class="highlight language-python">convert_excel_date(df, column_name)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Convert Excel's serial date format into Python datetime format.</p>
<p>This method mutates the original DataFrame.</p>
<p>Implementation is also from
<a href="https://stackoverflow.com/questions/38454403/convert-excel-style-date-with-pandas">Stack Overflow</a></p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = convert_excel_date(df, column_name='date')
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    df = pd.DataFrame(...).convert_excel_date('date')
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>A column name.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with corrected dates.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if there are non numeric values in the column.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/convert_date.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def convert_excel_date(
    df: pd.DataFrame, column_name: Hashable
) -&gt; pd.DataFrame:
    """
    Convert Excel's serial date format into Python datetime format.

    This method mutates the original DataFrame.

    Implementation is also from
    [Stack Overflow](https://stackoverflow.com/questions/38454403/convert-excel-style-date-with-pandas)

    Functional usage syntax:

    ```python
        df = convert_excel_date(df, column_name='date')
    ```

    Method chaining syntax:

    ```python
        import pandas as pd
        import janitor
        df = pd.DataFrame(...).convert_excel_date('date')
    ```

    :param df: A pandas DataFrame.
    :param column_name: A column name.
    :returns: A pandas DataFrame with corrected dates.
    :raises ValueError: if there are non numeric values in the column.
    """  # noqa: E501

    if not is_numeric_dtype(df[column_name]):
        raise ValueError(
            "There are non-numeric values in the column. \
    All values must be numeric"
        )

    df[column_name] = pd.TimedeltaIndex(
        df[column_name], unit="d"
    ) + dt.datetime(
        1899, 12, 30
    )  # noqa: W503
    return df
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.convert_date.convert_matlab_date" class="doc doc-heading">
<code class="highlight language-python">convert_matlab_date(df, column_name)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Convert Matlab's serial date number into Python datetime format.</p>
<p>Implementation is also from
<a href="https://stackoverflow.com/questions/13965740/converting-matlabs-datenum-format-to-python">Stack Overflow</a></p>
<p>This method mutates the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = convert_matlab_date(df, column_name='date')
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    df = pd.DataFrame(...).convert_matlab_date('date')
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>A column name.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with corrected dates.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/convert_date.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def convert_matlab_date(
    df: pd.DataFrame, column_name: Hashable
) -&gt; pd.DataFrame:
    """
    Convert Matlab's serial date number into Python datetime format.

    Implementation is also from
    [Stack Overflow](https://stackoverflow.com/questions/13965740/converting-matlabs-datenum-format-to-python)

    This method mutates the original DataFrame.

    Functional usage syntax:

    ```python
        df = convert_matlab_date(df, column_name='date')
    ```

    Method chaining syntax:

    ```python
        import pandas as pd
        import janitor
        df = pd.DataFrame(...).convert_matlab_date('date')
    ```

    :param df: A pandas DataFrame.
    :param column_name: A column name.
    :returns: A pandas DataFrame with corrected dates.
    """  # noqa: E501
    days = pd.Series([dt.timedelta(v % 1) for v in df[column_name]])
    df[column_name] = (
        df[column_name].astype(int).apply(dt.datetime.fromordinal)
        + days
        - dt.timedelta(days=366)
    )
    return df
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.convert_date.convert_unix_date" class="doc doc-heading">
<code class="highlight language-python">convert_unix_date(df, column_name)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Convert unix epoch time into Python datetime format.</p>
<p>Note that this ignores local tz and convert all timestamps to naive
datetime based on UTC!</p>
<p>This method mutates the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = convert_unix_date(df, column_name='date')
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    df = pd.DataFrame(...).convert_unix_date('date')
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>A column name.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with corrected dates.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/convert_date.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def convert_unix_date(df: pd.DataFrame, column_name: Hashable) -&gt; pd.DataFrame:
    """
    Convert unix epoch time into Python datetime format.

    Note that this ignores local tz and convert all timestamps to naive
    datetime based on UTC!

    This method mutates the original DataFrame.

    Functional usage syntax:

    ```python
        df = convert_unix_date(df, column_name='date')
    ```

    Method chaining syntax:

    ```python
        import pandas as pd
        import janitor
        df = pd.DataFrame(...).convert_unix_date('date')
    ```

    :param df: A pandas DataFrame.
    :param column_name: A column name.
    :returns: A pandas DataFrame with corrected dates.
    """

    try:
        df[column_name] = pd.to_datetime(df[column_name], unit="s")
    except OutOfBoundsDatetime:  # Indicates time is in milliseconds.
        df[column_name] = pd.to_datetime(df[column_name], unit="ms")
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.count_cumulative_unique" class="doc doc-heading">
        <code>count_cumulative_unique</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.count_cumulative_unique.count_cumulative_unique" class="doc doc-heading">
<code class="highlight language-python">count_cumulative_unique(df, column_name, dest_column_name, case_sensitive=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Generates a running total of cumulative unique values in a given column.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)

    df = jn.functions.count_cumulative_unique(
        df=df,
        column_name='animals',
        dest_column_name='animals_unique_count',
        case_sensitive=True
    )
</code></pre>
<p>Method chaining usage example:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor

    df = pd.DataFrame(...)

    df = df.count_cumulative_unique(
        column_name='animals',
        dest_column_name='animals_unique_count',
        case_sensitive=True
    )
</code></pre>
<p>A new column will be created containing a running
count of unique values in the specified column.
If <code>case_sensitive</code> is <code>True</code>, then the case of
any letters will matter (i.e., <code>a != A</code>);
otherwise, the case of any letters will not matter.</p>
<p>This method mutates the original DataFrame.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Name of the column containing values from which a running count of unique values will be created.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dest_column_name</code></td>
        <td><code>str</code></td>
        <td><p>The name of the new column containing the cumulative count of unique values that will be created.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>case_sensitive</code></td>
        <td><code>bool</code></td>
        <td><p>Whether or not uppercase and lowercase letters will be considered equal (e.g., 'A' != 'a' if <code>True</code>).</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with a new column containing a cumulative count of unique values from another column.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/count_cumulative_unique.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def count_cumulative_unique(
    df: pd.DataFrame,
    column_name: Hashable,
    dest_column_name: str,
    case_sensitive: bool = True,
) -&gt; pd.DataFrame:
    """Generates a running total of cumulative unique values in a given column.

    Functional usage syntax:

    ```python
        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)

        df = jn.functions.count_cumulative_unique(
            df=df,
            column_name='animals',
            dest_column_name='animals_unique_count',
            case_sensitive=True
        )
    ```

    Method chaining usage example:

    ```python
        import pandas as pd
        import janitor

        df = pd.DataFrame(...)

        df = df.count_cumulative_unique(
            column_name='animals',
            dest_column_name='animals_unique_count',
            case_sensitive=True
        )
    ```

    A new column will be created containing a running
    count of unique values in the specified column.
    If `case_sensitive` is `True`, then the case of
    any letters will matter (i.e., `a != A`);
    otherwise, the case of any letters will not matter.

    This method mutates the original DataFrame.

    :param df: A pandas dataframe.
    :param column_name: Name of the column containing
        values from which a running count of unique values
        will be created.
    :param dest_column_name: The name of the new column containing the
        cumulative count of unique values that will be created.
    :param case_sensitive: Whether or not uppercase and lowercase letters
        will be considered equal (e.g., 'A' != 'a' if `True`).

    :returns: A pandas DataFrame with a new column containing a cumulative
        count of unique values from another column.
    """

    if not case_sensitive:
        # Make it so that the the same uppercase and lowercase
        # letter are treated as one unique value
        df[column_name] = df[column_name].astype(str).map(str.lower)

    df[dest_column_name] = (
        (
            df[[column_name]]
            .drop_duplicates()
            .assign(dummyabcxyz=1)
            .dummyabcxyz.cumsum()
        )
        .reindex(df.index)
        .ffill()
        .astype(int)
    )

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.currency_column_to_numeric" class="doc doc-heading">
        <code>currency_column_to_numeric</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.currency_column_to_numeric.currency_column_to_numeric" class="doc doc-heading">
<code class="highlight language-python">currency_column_to_numeric(df, column_name, cleaning_style=None, cast_non_numeric=None, fill_all_non_numeric=None, remove_non_numeric=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Convert currency column to numeric.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>This method allows one to take a column containing currency values,
inadvertently imported as a string, and cast it as a float. This is
usually the case when reading CSV files that were modified in Excel.
Empty strings (i.e. <code>''</code>) are retained as <code>NaN</code> values.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td></td>
        <td><p>The column to modify</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>cleaning_style</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>What style of cleaning to perform. If None, standard cleaning is applied. Options are:  * 'accounting': Replaces numbers in parentheses with negatives, removes commas.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>cast_non_numeric</code></td>
        <td><code>Optional[dict]</code></td>
        <td><p>A dict of how to coerce certain strings. For example, if there are values of 'REORDER' in the DataFrame, {'REORDER': 0} will cast all instances of 'REORDER' to 0.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>fill_all_non_numeric</code></td>
        <td><code>Union[float, int]</code></td>
        <td><p>Similar to <code>cast_non_numeric</code>, but fills all strings to the same value. For example,  fill_all_non_numeric=1, will make everything that doesn't coerce to a currency 1.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>remove_non_numeric</code></td>
        <td><code>bool</code></td>
        <td><p>Will remove rows of a DataFrame that contain non-numeric values in the <code>column_name</code> column. Defaults to <code>False</code>.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/currency_column_to_numeric.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(col_name="column_name", type="cleaning_style")
def currency_column_to_numeric(
    df: pd.DataFrame,
    column_name,
    cleaning_style: Optional[str] = None,
    cast_non_numeric: Optional[dict] = None,
    fill_all_non_numeric: Optional[Union[float, int]] = None,
    remove_non_numeric: bool = False,
) -&gt; pd.DataFrame:
    """Convert currency column to numeric.

    This method does not mutate the original DataFrame.

    This method allows one to take a column containing currency values,
    inadvertently imported as a string, and cast it as a float. This is
    usually the case when reading CSV files that were modified in Excel.
    Empty strings (i.e. `''`) are retained as `NaN` values.

    :param df: The DataFrame
    :param column_name: The column to modify
    :param cleaning_style: What style of cleaning to perform. If None, standard
        cleaning is applied. Options are:

            * 'accounting':
            Replaces numbers in parentheses with negatives, removes commas.

    :param cast_non_numeric: A dict of how to coerce certain strings. For
        example, if there are values of 'REORDER' in the DataFrame,
        {'REORDER': 0} will cast all instances of 'REORDER' to 0.
    :param fill_all_non_numeric: Similar to `cast_non_numeric`, but fills all
        strings to the same value. For example,  fill_all_non_numeric=1, will
        make everything that doesn't coerce to a currency 1.
    :param remove_non_numeric: Will remove rows of a DataFrame that contain
        non-numeric values in the `column_name` column. Defaults to `False`.
    :returns: A pandas DataFrame.
    """

    check("column_name", column_name, [str])

    column_series = df[column_name]
    if cleaning_style == "accounting":
        df.loc[:, column_name] = df[column_name].apply(
            _clean_accounting_column
        )
        return df

    if cast_non_numeric:
        check("cast_non_numeric", cast_non_numeric, [dict])

    _make_cc_patrial = partial(
        _currency_column_to_numeric, cast_non_numeric=cast_non_numeric
    )

    column_series = column_series.apply(_make_cc_patrial)

    if remove_non_numeric:
        df = df.loc[column_series != "", :]

    # _replace_empty_string_with_none is applied here after the check on
    # remove_non_numeric since "" is our indicator that a string was coerced
    # in the original column
    column_series = _replace_empty_string_with_none(column_series)

    if fill_all_non_numeric is not None:
        check("fill_all_non_numeric", fill_all_non_numeric, [int, float])
        column_series = column_series.fillna(fill_all_non_numeric)

    column_series = _replace_original_empty_string_with_none(column_series)

    df = df.assign(**{column_name: pd.to_numeric(column_series)})

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.deconcatenate_column" class="doc doc-heading">
        <code>deconcatenate_column</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.deconcatenate_column.deconcatenate_column" class="doc doc-heading">
<code class="highlight language-python">deconcatenate_column(df, column_name, sep=None, new_column_names=None, autoname=None, preserve_position=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>De-concatenates a single column into multiple columns.</p>
<p>The column to de-concatenate can be either a collection (list, tuple, ...)
which can be separated out with <code>pd.Series.tolist()``,
or a string to slice based on</code>sep``.</p>
<p>To determine this behaviour automatically,
the first element in the column specified is inspected.</p>
<p>If it is a string, then <code>sep</code> must be specified.
Else, the function assumes that it is an iterable type
(e.g. <code>list</code> or `tuple``),
and will attempt to deconcatenate by splitting the list.</p>
<p>Given a column with string values, this is the inverse of the
<code>concatenate_columns</code> function.</p>
<p>Used to quickly split columns out of a single column.</p>
<p>The keyword argument <code>preserve_position``
takes</code>True<code>or</code>False<code>boolean
that controls whether the</code>new_column_names<code>will take the original position
of the to-be-deconcatenated `column_name</code>:</p>
<ul>
<li>When <code>preserve_position=False</code> (default), <code>df.columns</code> change from
  <code>[..., column_name, ...]</code> to <code>[..., column_name, ..., new_column_names]</code>.
  In other words, the deconcatenated new columns are appended to the right
  of the original dataframe and the original <code>column_name</code> is NOT dropped.</li>
<li>When <code>preserve_position=True</code>, <code>df.column</code> change from
  <code>[..., column_name, ...]</code> to <code>[..., new_column_names, ...]</code>.
  In other words, the deconcatenated new column will REPLACE the original
  <code>column_name</code> at its original position, and <code>column_name</code> itself
  is dropped.</li>
</ul>
<p>The keyword argument <code>autoname</code> accepts a base string
and then automatically creates numbered column names
based off the base string.
For example, if <code>col</code> is passed in
as the argument to <code>autoname``,
and 4 columns are created,
then the resulting columns will be named</code>col1, col2, col3, col4``.
Numbering is always 1-indexed, not 0-indexed,
in order to make the column names human-friendly.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre class="highlight"><code>df = deconcatenate_column(
        df, column_name='id', new_column_names=['col1', 'col2'],
        sep='-', preserve_position=True
)
</code></pre>
<p>Method chaining syntax:</p>
<pre class="highlight"><code>df = (pd.DataFrame(...).
        deconcatenate_column(
            column_name='id', new_column_names=['col1', 'col2'],
            sep='-', preserve_position=True
        ))


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The column to split.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sep</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The separator delimiting the column's data.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>new_column_names</code></td>
        <td><code>Union[List[str], Tuple[str]]</code></td>
        <td><p>A list of new column names post-splitting.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>autoname</code></td>
        <td><code>str</code></td>
        <td><p>A base name for automatically naming the new columns. Takes precedence over <code>new_column_names</code> if both are provided.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>preserve_position</code></td>
        <td><code>bool</code></td>
        <td><p>Boolean for whether or not to preserve original position of the column upon de-concatenation, default to False</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with a deconcatenated column.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>column_name</code> is not present in the DataFrame.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>sep</code> is not provided and the column values are of type `str``.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if either <code>new_column_names</code> or `autoname`` is not supplied.</p></td>
      </tr>
      <tr>
        <td><code>JanitorError</code></td>
        <td><p>if incorrect number of names is provided within `new_column_names``.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/deconcatenate_column.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def deconcatenate_column(
    df: pd.DataFrame,
    column_name: Hashable,
    sep: Optional[str] = None,
    new_column_names: Optional[Union[List[str], Tuple[str]]] = None,
    autoname: str = None,
    preserve_position: bool = False,
) -&gt; pd.DataFrame:
    """De-concatenates a single column into multiple columns.

    The column to de-concatenate can be either a collection (list, tuple, ...)
    which can be separated out with `pd.Series.tolist()``,
    or a string to slice based on `sep``.

    To determine this behaviour automatically,
    the first element in the column specified is inspected.

    If it is a string, then `sep` must be specified.
    Else, the function assumes that it is an iterable type
    (e.g. `list` or `tuple``),
    and will attempt to deconcatenate by splitting the list.

    Given a column with string values, this is the inverse of the
    `concatenate_columns` function.

    Used to quickly split columns out of a single column.

    The keyword argument `preserve_position``
    takes `True` or `False` boolean
    that controls whether the `new_column_names``
    will take the original position
    of the to-be-deconcatenated `column_name``:

    - When `preserve_position=False` (default), `df.columns` change from
      `[..., column_name, ...]` to `[..., column_name, ..., new_column_names]`.
      In other words, the deconcatenated new columns are appended to the right
      of the original dataframe and the original `column_name` is NOT dropped.
    - When `preserve_position=True`, `df.column` change from
      `[..., column_name, ...]` to `[..., new_column_names, ...]`.
      In other words, the deconcatenated new column will REPLACE the original
      `column_name` at its original position, and `column_name` itself
      is dropped.

    The keyword argument `autoname` accepts a base string
    and then automatically creates numbered column names
    based off the base string.
    For example, if `col` is passed in
    as the argument to `autoname``,
    and 4 columns are created,
    then the resulting columns will be named
    `col1, col2, col3, col4``.
    Numbering is always 1-indexed, not 0-indexed,
    in order to make the column names human-friendly.

    This method does not mutate the original DataFrame.

    Functional usage syntax:

        df = deconcatenate_column(
                df, column_name='id', new_column_names=['col1', 'col2'],
                sep='-', preserve_position=True
        )

    Method chaining syntax:

        df = (pd.DataFrame(...).
                deconcatenate_column(
                    column_name='id', new_column_names=['col1', 'col2'],
                    sep='-', preserve_position=True
                ))

    :param df: A pandas DataFrame.
    :param column_name: The column to split.
    :param sep: The separator delimiting the column's data.
    :param new_column_names: A list of new column names post-splitting.
    :param autoname: A base name for automatically naming the new columns.
        Takes precedence over `new_column_names` if both are provided.
    :param preserve_position: Boolean for whether or not to preserve original
        position of the column upon de-concatenation, default to False
    :returns: A pandas DataFrame with a deconcatenated column.
    :raises ValueError: if `column_name` is not present in the
        DataFrame.
    :raises ValueError: if `sep` is not provided and the column values
        are of type `str``.
    :raises ValueError: if either `new_column_names` or `autoname``
        is not supplied.
    :raises JanitorError: if incorrect number of names is provided
        within `new_column_names``.
    """

    if column_name not in df.columns:
        raise ValueError(f"column name {column_name} not present in DataFrame")

    if isinstance(df[column_name].iloc[0], str):
        if sep is None:
            raise ValueError(
                "`sep` must be specified if the column values "
                "are of type `str`."
            )
        df_deconcat = df[column_name].str.split(sep, expand=True)
    else:
        df_deconcat = pd.DataFrame(
            df[column_name].to_list(), columns=new_column_names, index=df.index
        )

    if new_column_names is None and autoname is None:
        raise ValueError(
            "One of `new_column_names` or `autoname` must be supplied."
        )

    if autoname:
        new_column_names = [
            f"{autoname}{i}" for i in range(1, df_deconcat.shape[1] + 1)
        ]

    if not len(new_column_names) == df_deconcat.shape[1]:
        raise JanitorError(
            f"you need to provide {len(df_deconcat.shape[1])} names "
            "to `new_column_names`"
        )

    df_deconcat.columns = new_column_names
    df_new = pd.concat([df, df_deconcat], axis=1)

    if preserve_position:
        df_original = df.copy()
        cols = list(df_original.columns)
        index_original = cols.index(column_name)

        for i, col_new in enumerate(new_column_names):
            cols.insert(index_original + i, col_new)

        df_new = df_new.select_columns(cols).drop(columns=column_name)

    return df_new
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.drop_constant_columns" class="doc doc-heading">
        <code>drop_constant_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.drop_constant_columns.drop_constant_columns" class="doc doc-heading">
<code class="highlight language-python">drop_constant_columns(df)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Finds and drops the constant columns from a Pandas DataFrame.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

data_dict = {
&quot;a&quot;: [1, 1, 1] * 3,
&quot;Bell__Chart&quot;: [1, 2, 3] * 3,
&quot;decorated-elephant&quot;: [1, 1, 1] * 3,
&quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,
&quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3
}

df = pd.DataFrame(data_dict)

df = jn.functions.drop_constant_columns(df)
</code></pre>
<p>Method chaining usage example:</p>
<pre><code class="language-python">import pandas as pd
import janitor

df = pd.DataFrame(...)

df = df.drop_constant_columns()
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>Input Pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>The Pandas DataFrame with the constant columns dropped.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/drop_constant_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def drop_constant_columns(
    df: pd.DataFrame,
) -&gt; pd.DataFrame:
    """
    Finds and drops the constant columns from a Pandas DataFrame.

    This method does not mutate the original DataFrame.

    Functional usage syntax:

    ```python
    import pandas as pd
    import janitor as jn

    data_dict = {
    "a": [1, 1, 1] * 3,
    "Bell__Chart": [1, 2, 3] * 3,
    "decorated-elephant": [1, 1, 1] * 3,
    "animals": ["rabbit", "leopard", "lion"] * 3,
    "cities": ["Cambridge", "Shanghai", "Basel"] * 3
    }

    df = pd.DataFrame(data_dict)

    df = jn.functions.drop_constant_columns(df)
    ```

    Method chaining usage example:

    ```python
    import pandas as pd
    import janitor

    df = pd.DataFrame(...)

    df = df.drop_constant_columns()
    ```

    :param df: Input Pandas DataFrame
    :returns: The Pandas DataFrame with the constant columns dropped.
    """
    # Find the constant columns
    constant_columns = []
    for col in df.columns:
        if len(df[col].unique()) == 1:
            constant_columns.append(col)

    # Drop constant columns from df and return it
    return df.drop(labels=constant_columns, axis=1)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.drop_duplicate_columns" class="doc doc-heading">
        <code>drop_duplicate_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.drop_duplicate_columns.drop_duplicate_columns" class="doc doc-heading">
<code class="highlight language-python">drop_duplicate_columns(df, column_name, nth_index=0)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Remove a duplicated column specified by column_name, its index.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Column order 0 is to remove the first column,
       order 1 is to remove the second column, and etc</p>
<p>The corresponding tidyverse R's library is:
<code>select(-&lt;column_name&gt;_&lt;nth_index + 1&gt;)</code></p>
<p>Method chaining syntax:</p>
<pre class="highlight"><code>df = pd.DataFrame({
    "a": range(10),
    "b": range(10),
    "A": range(10, 20),
    "a*": range(20, 30),
}).clean_names(remove_special=True)

# remove a duplicated second 'a' column
df.drop_duplicate_columns(column_name="a", nth_index=1)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Column to be removed</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>nth_index</code></td>
        <td><code>int</code></td>
        <td><p>Among the duplicated columns, select the nth column to drop.</p></td>
        <td><code>0</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/drop_duplicate_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def drop_duplicate_columns(
    df: pd.DataFrame, column_name: Hashable, nth_index: int = 0
) -&gt; pd.DataFrame:
    """Remove a duplicated column specified by column_name, its index.

    This method does not mutate the original DataFrame.

    Column order 0 is to remove the first column,
           order 1 is to remove the second column, and etc

    The corresponding tidyverse R's library is:
    `select(-&lt;column_name&gt;_&lt;nth_index + 1&gt;)`

    Method chaining syntax:



        df = pd.DataFrame({
            "a": range(10),
            "b": range(10),
            "A": range(10, 20),
            "a*": range(20, 30),
        }).clean_names(remove_special=True)

        # remove a duplicated second 'a' column
        df.drop_duplicate_columns(column_name="a", nth_index=1)



    :param df: A pandas DataFrame
    :param column_name: Column to be removed
    :param nth_index: Among the duplicated columns,
        select the nth column to drop.
    :return: A pandas DataFrame
    """
    cols = df.columns.to_list()
    col_indexes = [
        col_idx
        for col_idx, col_name in enumerate(cols)
        if col_name == column_name
    ]

    # given that a column could be duplicated,
    # user could opt based on its order
    removed_col_idx = col_indexes[nth_index]
    # get the column indexes without column that is being removed
    filtered_cols = [
        c_i for c_i, c_v in enumerate(cols) if c_i != removed_col_idx
    ]

    return df.iloc[:, filtered_cols]
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.dropnotnull" class="doc doc-heading">
        <code>dropnotnull</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.dropnotnull.dropnotnull" class="doc doc-heading">
<code class="highlight language-python">dropnotnull(df, column_name)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Drop rows that do not have null values in the given column.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Example usage:</p>
<pre><code class="language-python">    df = pd.DataFrame(...).dropnotnull('column3')
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The column name to drop rows from.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with dropped rows.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/dropnotnull.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def dropnotnull(df: pd.DataFrame, column_name: Hashable) -&gt; pd.DataFrame:
    """
    Drop rows that do not have null values in the given column.

    This method does not mutate the original DataFrame.

    Example usage:

    ```python
        df = pd.DataFrame(...).dropnotnull('column3')
    ```

    :param df: A pandas DataFrame.
    :param column_name: The column name to drop rows from.
    :returns: A pandas DataFrame with dropped rows.
    """
    return df[pd.isna(df[column_name])]
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.encode_categorical" class="doc doc-heading">
        <code>encode_categorical</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.encode_categorical.encode_categorical" class="doc doc-heading">
<code class="highlight language-python">encode_categorical(df, column_names=None, **kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Encode the specified columns with Pandas' <a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html">category dtype</a>.</p>
<p>It is syntactic sugar around <code>pd.Categorical</code>.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Note: In versions &lt; 0.20.11, this method mutates the original DataFrame.</p>
<p>TODO: The big chunk of examples below
should be moved into a Jupyter notebook.
This will keep the docstring consistent and to-the-point.</p>
<p>Examples:</p>
<pre><code class="language-python">    col1    col2    col3
0   2.0     a       2020-01-01
1   1.0     b       2020-01-02
2   3.0     c       2020-01-03
3   1.0     d       2020-01-04
4   NaN     a       2020-01-05

df.dtypes

col1           float64
col2            object
col3    datetime64[ns]
dtype: object
</code></pre>
<p>Specific columns can be converted to category type:</p>
<pre><code class="language-python">df = (
    pd.DataFrame(...)
    .encode_categorical(
        column_names=['col1', 'col2', 'col3']
    )
)

df.dtypes

col1    category
col2    category
col3    category
dtype: object
</code></pre>
<p>Note that for the code above, the categories were inferred from
the columns, and is unordered:</p>
<pre class="highlight"><code>df['col3']
0   2020-01-01
1   2020-01-02
2   2020-01-03
3   2020-01-04
4   2020-01-05
Name: col3, dtype: category
Categories (5, datetime64[ns]):
[2020-01-01, 2020-01-02, 2020-01-03, 2020-01-04, 2020-01-05]

</code></pre>
<p>Explicit categories can be provided, and ordered via the `kwargs``
parameter:</p>
<pre class="highlight"><code>df = (pd.DataFrame(...)
        .encode_categorical(
            col1 = ([3, 2, 1, 4], "appearance"),
            col2 = (['a','d','c','b'], "sort")
            )
    )

df['col1']
0      2
1      1
2      3
3      1
4    NaN
Name: col1, dtype: category
Categories (4, int64): [3 &lt; 2 &lt; 1 &lt; 4]

df['col2']
0    a
1    b
2    c
3    d
4    a
Name: col2, dtype: category
Categories (4, object): [a &lt; b &lt; c &lt; d]
</code></pre>
<p>When the <code>order</code> parameter is "appearance",
the categories argument is used as-is;
if the <code>order</code> is "sort",
the categories argument is sorted in ascending order;
if <code>order</code> is `None``,
then the categories argument is applied unordered.</p>
<p>A User Warning will be generated if some or all of the unique values
in the column are not present in the provided <code>categories</code> argument.</p>
<pre><code class="language-python">    df = (pd.DataFrame(...)
            .encode_categorical(
                col1 = (
                        categories = [4, 5, 6],
                        order = &quot;appearance&quot;
                        )
        )

    UserWarning: None of the values in col1 are in [4, 5, 6];
                 this might create nulls for all your values
                 in the new categorical column.

    df['col1']
    0    NaN
    1    NaN
    2    NaN
    3    NaN
    4    NaN
    Name: col1, dtype: category
    Categories (3, int64): [4 &lt; 5 &lt; 6]
</code></pre>
<p>.. note:: if <code>categories</code> is None in the <code>kwargs</code> tuple, then the
    values for <code>categories</code> are inferred from the column; if <code>order</code>
    is None, then the values for categories are applied unordered.</p>
<p>.. note:: <code>column_names</code> and <code>kwargs</code> parameters cannot be used at
    the same time.</p>
<p>Functional usage syntax:</p>
<p>```python</p>
<pre class="highlight"><code>import pandas as pd
import janitor as jn
</code></pre>
<ul>
<li>
<p>With `column_names``::</p>
<p>categorical_cols = ['col1', 'col2', 'col4']
df = jn.encode_categorical(
            df,
            columns = categorical_cols)  # one way</p>
</li>
<li>
<p>With `kwargs``::</p>
<p>df = jn.encode_categorical(
            df,
            col1 = (categories, order),
            col2 = (categories = [values],
            order="sort"  # or "appearance" or None</p>
<pre class="highlight"><code>    )
</code></pre>
</li>
</ul>
<p>Method chaining syntax:</p>
<ul>
<li>
<p>With `column_names``::</p>
<p>categorical_cols = ['col1', 'col2', 'col4']
df = (pd.DataFrame(...)
        .encode_categorical(columns=categorical_cols)
    )</p>
</li>
<li>
<p>With `kwargs``::</p>
<p>df = (
    pd.DataFrame(...)
    .encode_categorical(
        col1 = (categories, order),
        col2 = (categories = [values]/None,
                order="sort"  # or "appearance" or None
                )
)</p>
</li>
</ul>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[str, Iterable[str], Hashable]</code></td>
        <td><p>A column name or an iterable (list or tuple) of column names.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>A pairing of column name to a tuple of (<code>categories</code>, <code>order</code>). This is useful in creating categorical columns that are ordered, or if the user needs to explicitly specify the categories.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if both <code>column_names</code> and <code>kwargs</code> are provided.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/encode_categorical.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names")
def encode_categorical(
    df: pd.DataFrame,
    column_names: Union[str, Iterable[str], Hashable] = None,
    **kwargs,
) -&gt; pd.DataFrame:
    """Encode the specified columns with Pandas' [category dtype][cat].

    [cat]: http://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html

    It is syntactic sugar around `pd.Categorical`.

    This method does not mutate the original DataFrame.

    Note: In versions &lt; 0.20.11, this method mutates the original DataFrame.

    TODO: The big chunk of examples below
    should be moved into a Jupyter notebook.
    This will keep the docstring consistent and to-the-point.

    Examples:

    ```python
        col1	col2	col3
    0	2.0	a	2020-01-01
    1	1.0	b	2020-01-02
    2	3.0	c	2020-01-03
    3	1.0	d	2020-01-04
    4	NaN	a	2020-01-05

    df.dtypes

    col1           float64
    col2            object
    col3    datetime64[ns]
    dtype: object
    ```

    Specific columns can be converted to category type:

    ```python
    df = (
        pd.DataFrame(...)
        .encode_categorical(
            column_names=['col1', 'col2', 'col3']
        )
    )

    df.dtypes

    col1    category
    col2    category
    col3    category
    dtype: object
    ```

    Note that for the code above, the categories were inferred from
    the columns, and is unordered:

        df['col3']
        0   2020-01-01
        1   2020-01-02
        2   2020-01-03
        3   2020-01-04
        4   2020-01-05
        Name: col3, dtype: category
        Categories (5, datetime64[ns]):
        [2020-01-01, 2020-01-02, 2020-01-03, 2020-01-04, 2020-01-05]


    Explicit categories can be provided, and ordered via the `kwargs``
    parameter:

        df = (pd.DataFrame(...)
                .encode_categorical(
                    col1 = ([3, 2, 1, 4], "appearance"),
                    col2 = (['a','d','c','b'], "sort")
                    )
            )

        df['col1']
        0      2
        1      1
        2      3
        3      1
        4    NaN
        Name: col1, dtype: category
        Categories (4, int64): [3 &lt; 2 &lt; 1 &lt; 4]

        df['col2']
        0    a
        1    b
        2    c
        3    d
        4    a
        Name: col2, dtype: category
        Categories (4, object): [a &lt; b &lt; c &lt; d]

    When the `order` parameter is "appearance",
    the categories argument is used as-is;
    if the `order` is "sort",
    the categories argument is sorted in ascending order;
    if `order` is `None``,
    then the categories argument is applied unordered.


    A User Warning will be generated if some or all of the unique values
    in the column are not present in the provided `categories` argument.

    ```python
        df = (pd.DataFrame(...)
                .encode_categorical(
                    col1 = (
                            categories = [4, 5, 6],
                            order = "appearance"
                            )
            )

        UserWarning: None of the values in col1 are in [4, 5, 6];
                     this might create nulls for all your values
                     in the new categorical column.

        df['col1']
        0    NaN
        1    NaN
        2    NaN
        3    NaN
        4    NaN
        Name: col1, dtype: category
        Categories (3, int64): [4 &lt; 5 &lt; 6]
    ```

    .. note:: if `categories` is None in the `kwargs` tuple, then the
        values for `categories` are inferred from the column; if `order`
        is None, then the values for categories are applied unordered.

    .. note:: `column_names` and `kwargs` parameters cannot be used at
        the same time.

    Functional usage syntax:

    ```python

        import pandas as pd
        import janitor as jn

    - With `column_names``::

        categorical_cols = ['col1', 'col2', 'col4']
        df = jn.encode_categorical(
                    df,
                    columns = categorical_cols)  # one way

    - With `kwargs``::

        df = jn.encode_categorical(
                    df,
                    col1 = (categories, order),
                    col2 = (categories = [values],
                    order="sort"  # or "appearance" or None

                )

    Method chaining syntax:

    - With `column_names``::

        categorical_cols = ['col1', 'col2', 'col4']
        df = (pd.DataFrame(...)
                .encode_categorical(columns=categorical_cols)
            )

    - With `kwargs``::

        df = (
            pd.DataFrame(...)
            .encode_categorical(
                col1 = (categories, order),
                col2 = (categories = [values]/None,
                        order="sort"  # or "appearance" or None
                        )
        )

    :param df: The pandas DataFrame object.
    :param column_names: A column name or an iterable (list or
        tuple) of column names.
    :param kwargs: A pairing of column name to a tuple of (`categories`, `order`).
        This is useful in creating categorical columns that are ordered, or
        if the user needs to explicitly specify the categories.
    :returns: A pandas DataFrame.
    :raises ValueError: if both ``column_names`` and ``kwargs`` are provided.
    """  # noqa: E501

    if all((column_names, kwargs)):
        raise ValueError(
            """
            Only one of `column_names` or `kwargs`
            can be provided.
            """
        )
    # column_names deal with only category dtype (unordered)
    # kwargs takes care of scenarios where user wants an ordered category
    # or user supplies specific categories to create the categorical
    if column_names is not None:
        check("column_names", column_names, [list, tuple, Hashable])
        if isinstance(column_names, (list, tuple)):
            check_column(df, column_names)
            dtypes = {col: "category" for col in column_names}
            return df.astype(dtypes)
        if isinstance(column_names, Hashable):
            check_column(df, [column_names])
            return df.astype({column_names: "category"})

    return _computations_as_categorical(df, **kwargs)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.expand_column" class="doc doc-heading">
        <code>expand_column</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.expand_column.expand_column" class="doc doc-heading">
<code class="highlight language-python">expand_column(df, column_name, sep='|', concat=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Expand a categorical column with multiple labels into dummy-coded columns.</p>
<p>Super sugary syntax that wraps :py:meth:<code>pandas.Series.str.get_dummies</code>.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre class="highlight"><code>df = expand_column(
    df,
    column_name='col_name',
    sep=', '  # note space in sep
)
</code></pre>
<p>Method chaining syntax:</p>
<pre class="highlight"><code>import pandas as pd
import janitor
df = (
    pd.DataFrame(...)
    .expand_column(
        column_name='col_name',
        sep=', '
    )
)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Which column to expand.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sep</code></td>
        <td><code>str</code></td>
        <td><p>The delimiter, same to :py:meth:<code>~pandas.Series.str.get_dummies</code>'s <code>sep</code>, default as <code>|</code>.</p></td>
        <td><code>&#39;|&#39;</code></td>
      </tr>
      <tr>
        <td><code>concat</code></td>
        <td><code>bool</code></td>
        <td><p>Whether to return the expanded column concatenated to the original dataframe (<code>concat=True</code>), or to return it standalone (<code>concat=False</code>).</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with an expanded column.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/expand_column.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def expand_column(
    df: pd.DataFrame,
    column_name: Hashable,
    sep: str = "|",
    concat: bool = True,
) -&gt; pd.DataFrame:
    """Expand a categorical column with multiple labels into dummy-coded columns.

    Super sugary syntax that wraps :py:meth:`pandas.Series.str.get_dummies`.

    This method does not mutate the original DataFrame.

    Functional usage syntax:

        df = expand_column(
            df,
            column_name='col_name',
            sep=', '  # note space in sep
        )

    Method chaining syntax:

        import pandas as pd
        import janitor
        df = (
            pd.DataFrame(...)
            .expand_column(
                column_name='col_name',
                sep=', '
            )
        )

    :param df: A pandas DataFrame.
    :param column_name: Which column to expand.
    :param sep: The delimiter, same to
        :py:meth:`~pandas.Series.str.get_dummies`'s `sep`, default as `|`.
    :param concat: Whether to return the expanded column concatenated to
        the original dataframe (`concat=True`), or to return it standalone
        (`concat=False`).
    :returns: A pandas DataFrame with an expanded column.
    """
    expanded_df = df[column_name].str.get_dummies(sep=sep)
    if concat:
        df = df.join(expanded_df)
        return df
    return expanded_df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.expand_grid" class="doc doc-heading">
        <code>expand_grid</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.expand_grid.expand_grid" class="doc doc-heading">
<code class="highlight language-python">expand_grid(df=None, df_key=None, *, others=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Creates a DataFrame from a cartesian combination of all inputs.</p>
<p>It is not restricted to DataFrame;
it can work with any list-like structure
that is 1 or 2 dimensional.</p>
<p>If method-chaining to a DataFrame, a string argument
to <code>df_key</code> parameter must be provided.</p>
<p>Data types are preserved in this function,
including Pandas' extension array dtypes.</p>
<p>The output will always be a DataFrame, usually a MultiIndex,
with the keys of the <code>others</code> dictionary serving as
the top level columns.</p>
<p>If a DataFrame with MultiIndex columns is part of the arguments in
<code>others</code>, the columns are flattened, before the final
cartesian DataFrame is generated.</p>
<p>If a Pandas Series/DataFrame is passed, and has a labeled index, or
a MultiIndex index, the index is discarded; the final DataFrame
will have a RangeIndex.</p>
<p>The MultiIndexed DataFrame can be flattened using pyjanitor's
<code>collapse_levels</code> method; the user can also decide to drop any of the
levels, via Pandas' <code>droplevel</code> method.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)
    df = jn.expand_grid(df=df, df_key=&quot;...&quot;, others={...})
</code></pre>
<p>Method-chaining usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...).expand_grid(df_key=&quot;bla&quot;,others={...})
</code></pre>
<p>Usage independent of a DataFrame</p>
<p>.. code-block:: python</p>
<p>```python
    import pandas as pd
    from janitor import expand_grid</p>
<pre class="highlight"><code>df = expand_grid(others = {"x":range(1,4), "y":[1,2]})


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>Optional[pandas.core.frame.DataFrame]</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>df_key</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>name of key for the dataframe. It becomes part of the column names of the dataframe.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>others</code></td>
        <td><code>Optional[Dict]</code></td>
        <td><p>A dictionary that contains the data to be combined with the dataframe. If no dataframe exists, all inputs in <code>others</code> will be combined to create a DataFrame.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame of the cartesian product.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>if there is a DataFrame and <code>df_key</code> is not provided.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/expand_grid.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def expand_grid(
    df: Optional[pd.DataFrame] = None,
    df_key: Optional[str] = None,
    *,
    others: Optional[Dict] = None,
) -&gt; pd.DataFrame:
    """
    Creates a DataFrame from a cartesian combination of all inputs.

    It is not restricted to DataFrame;
    it can work with any list-like structure
    that is 1 or 2 dimensional.

    If method-chaining to a DataFrame, a string argument
    to `df_key` parameter must be provided.


    Data types are preserved in this function,
    including Pandas' extension array dtypes.

    The output will always be a DataFrame, usually a MultiIndex,
    with the keys of the `others` dictionary serving as
    the top level columns.

    If a DataFrame with MultiIndex columns is part of the arguments in
    `others`, the columns are flattened, before the final
    cartesian DataFrame is generated.

    If a Pandas Series/DataFrame is passed, and has a labeled index, or
    a MultiIndex index, the index is discarded; the final DataFrame
    will have a RangeIndex.

    The MultiIndexed DataFrame can be flattened using pyjanitor's
    `collapse_levels` method; the user can also decide to drop any of the
    levels, via Pandas' `droplevel` method.

    Functional usage syntax:

    ```python

        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)
        df = jn.expand_grid(df=df, df_key="...", others={...})
    ```

    Method-chaining usage syntax:

    ```python
        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...).expand_grid(df_key="bla",others={...})
    ```

    Usage independent of a DataFrame

    .. code-block:: python

    ```python
        import pandas as pd
        from janitor import expand_grid

        df = expand_grid(others = {"x":range(1,4), "y":[1,2]})

    :param df: A pandas DataFrame.
    :param df_key: name of key for the dataframe.
        It becomes part of the column names of the dataframe.
    :param others: A dictionary that contains the data
        to be combined with the dataframe.
        If no dataframe exists, all inputs
        in `others` will be combined to create a DataFrame.
    :returns: A pandas DataFrame of the cartesian product.
    :raises KeyError: if there is a DataFrame and `df_key` is not provided.
    """

    if not others:
        if df is not None:
            return df
        return

    check("others", others, [dict])

    # if there is a DataFrame, for the method chaining,
    # it must have a key, to create a name value pair
    if df is not None:
        df = df.copy()

        if not df_key:
            raise KeyError(
                """
                Using `expand_grid` as part of a
                DataFrame method chain requires that
                a string argument be provided for
                the `df_key` parameter.
                """
            )

        check("df_key", df_key, [str])

        others = {**{df_key: df}, **others}

    return _computations_expand_grid(others)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.factorize_columns" class="doc doc-heading">
        <code>factorize_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.factorize_columns.factorize_columns" class="doc doc-heading">
<code class="highlight language-python">factorize_columns(df, column_names, suffix='_enc', **kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Converts labels into numerical data</p>
<p>This method will create a new column with the string <code>_enc</code> appended
after the original column's name.
This can be overriden with the suffix parameter.</p>
<p>Internally this method uses pandas <code>factorize</code> method.
It takes in an optional suffix and keyword arguments also.
An empty string as suffix will override the existing column.</p>
<p>This method mutates the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = factorize_columns(
    df,
    column_names=&quot;my_categorical_column&quot;,
    suffix=&quot;_enc&quot;
)  # one way
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
categorical_cols = ['col1', 'col2', 'col4']
df = (
    pd.DataFrame(...)
    .factorize_columns(
        column_names=categorical_cols,
        suffix=&quot;_enc&quot;
    )
)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[str, Iterable[str], Hashable]</code></td>
        <td><p>A column name or an iterable (list or tuple) of column names.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>suffix</code></td>
        <td><code>str</code></td>
        <td><p>Suffix to be used for the new column. Default value is _enc. An empty string suffix means, it will override the existing column</p></td>
        <td><code>&#39;_enc&#39;</code></td>
      </tr>
      <tr>
        <td><code>**kwargs</code></td>
        <td></td>
        <td><p>Keyword arguments. It takes any of the keyword arguments, which the pandas factorize method takes like sort,na_sentinel,size_hint</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/factorize_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def factorize_columns(
    df: pd.DataFrame,
    column_names: Union[str, Iterable[str], Hashable],
    suffix: str = "_enc",
    **kwargs,
) -&gt; pd.DataFrame:
    """
    Converts labels into numerical data

    This method will create a new column with the string `_enc` appended
    after the original column's name.
    This can be overriden with the suffix parameter.

    Internally this method uses pandas `factorize` method.
    It takes in an optional suffix and keyword arguments also.
    An empty string as suffix will override the existing column.

    This method mutates the original DataFrame.

    Functional usage syntax:

    ```python
    df = factorize_columns(
        df,
        column_names="my_categorical_column",
        suffix="_enc"
    )  # one way
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    categorical_cols = ['col1', 'col2', 'col4']
    df = (
        pd.DataFrame(...)
        .factorize_columns(
            column_names=categorical_cols,
            suffix="_enc"
        )
    )
    ```

    :param df: The pandas DataFrame object.
    :param column_names: A column name or an iterable (list
        or tuple) of column names.
    :param suffix: Suffix to be used for the new column. Default value is _enc.
        An empty string suffix means, it will override the existing column
    :param **kwargs: Keyword arguments. It takes any of the keyword arguments,
        which the pandas factorize method takes like sort,na_sentinel,size_hint

    :returns: A pandas DataFrame.
    """
    df = _factorize(df, column_names, suffix, **kwargs)
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.fill" class="doc doc-heading">
        <code>fill</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.fill.fill_direction" class="doc doc-heading">
<code class="highlight language-python">fill_direction(df, **kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Provide a method-chainable function for filling missing values
in selected columns.</p>
<p>It is a wrapper for <code>pd.Series.ffill</code> and <code>pd.Series.bfill</code>,
and pairs the column name with one of <code>up</code>, <code>down</code>, <code>updown</code>,
and <code>downup</code>.</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

df

            text  code
0      ragnar   NaN
1         NaN   2.0
2  sammywemmy   3.0
3         NaN   NaN
4      ginger   5.0
</code></pre>
<p>Fill on a single column:</p>
<pre><code class="language-python">df.fill_direction(code = 'up')

            text  code
0      ragnar   2.0
1         NaN   2.0
2  sammywemmy   3.0
3         NaN   5.0
4      ginger   5.0
</code></pre>
<p>Fill on multiple columns:</p>
<pre><code class="language-python">df.fill_direction(text = 'down', code = 'down')

            text  code
0      ragnar   NaN
1      ragnar   2.0
2  sammywemmy   3.0
3  sammywemmy   3.0
4      ginger   5.0
</code></pre>
<p>Fill multiple columns in different directions:</p>
<pre><code class="language-python">df.fill_direction(text = 'up', code = 'down')

            text  code
0      ragnar   NaN
1  sammywemmy   2.0
2  sammywemmy   3.0
3      ginger   3.0
4      ginger   5.0
</code></pre>
<p>Functional usage syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

df = pd.DataFrame(...)
df = jn.fill_direction(
            df = df,
            column_1 = direction_1,
            column_2 = direction_2,
        )
</code></pre>
<p>Method-chaining usage syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

df = pd.DataFrame(...)
        .fill_direction(
            column_1 = direction_1,
            column_2 = direction_2,
        )
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>Key - value pairs of columns and directions. Directions can be either <code>down</code>, <code>up</code>, <code>updown</code> (fill up then down) and <code>downup</code> (fill down then up).</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with modified column(s).</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if column supplied is not in the DataFrame.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if direction supplied is not one of <code>down</code>, <code>up</code>, <code>updown</code>, or <code>downup</code>.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/fill.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def fill_direction(df: pd.DataFrame, **kwargs) -&gt; pd.DataFrame:
    """
    Provide a method-chainable function for filling missing values
    in selected columns.

    It is a wrapper for `pd.Series.ffill` and `pd.Series.bfill`,
    and pairs the column name with one of `up`, `down`, `updown`,
    and `downup`.

    ```python
    import pandas as pd
    import janitor as jn

    df

                text  code
    0      ragnar   NaN
    1         NaN   2.0
    2  sammywemmy   3.0
    3         NaN   NaN
    4      ginger   5.0
    ```


    Fill on a single column:

    ```python
    df.fill_direction(code = 'up')

                text  code
    0      ragnar   2.0
    1         NaN   2.0
    2  sammywemmy   3.0
    3         NaN   5.0
    4      ginger   5.0
    ```

    Fill on multiple columns:

    ```python
    df.fill_direction(text = 'down', code = 'down')

                text  code
    0      ragnar   NaN
    1      ragnar   2.0
    2  sammywemmy   3.0
    3  sammywemmy   3.0
    4      ginger   5.0
    ```

    Fill multiple columns in different directions:

    ```python
    df.fill_direction(text = 'up', code = 'down')

                text  code
    0      ragnar   NaN
    1  sammywemmy   2.0
    2  sammywemmy   3.0
    3      ginger   3.0
    4      ginger   5.0
    ```

    Functional usage syntax:

    ```python
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)
    df = jn.fill_direction(
                df = df,
                column_1 = direction_1,
                column_2 = direction_2,
            )
    ```

    Method-chaining usage syntax:

    ```python
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)
            .fill_direction(
                column_1 = direction_1,
                column_2 = direction_2,
            )
    ```

    :param df: A pandas DataFrame.
    :param kwargs: Key - value pairs of columns and directions.
        Directions can be either `down`, `up`, `updown`
        (fill up then down) and `downup` (fill down then up).
    :returns: A pandas DataFrame with modified column(s).
    :raises ValueError: if column supplied is not in the DataFrame.
    :raises ValueError: if direction supplied is not one of `down`, `up`,
        `updown`, or `downup`.
    """

    if not kwargs:
        return df

    fill_types = {fill.name for fill in _FILLTYPE}
    for column_name, fill_type in kwargs.items():
        check("column_name", column_name, [str])
        check("fill_type", fill_type, [str])
        if fill_type.upper() not in fill_types:
            raise ValueError(
                """
                fill_type should be one of
                up, down, updown, or downup.
                """
            )

    check_column(df, kwargs)

    new_values = {}
    for column_name, fill_type in kwargs.items():
        direction = _FILLTYPE[f"{fill_type.upper()}"].value
        if len(direction) == 1:
            direction = methodcaller(direction[0])
            output = direction(df[column_name])
        else:
            direction = [methodcaller(entry) for entry in direction]
            output = _chain_func(df[column_name], *direction)
        new_values[column_name] = output

    return df.assign(**new_values)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.fill.fill_empty" class="doc doc-heading">
<code class="highlight language-python">fill_empty(df, column_names, value)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Fill <code>NaN</code> values in specified columns with a given value.</p>
<p>Super sugary syntax that wraps <code>pandas.DataFrame.fillna</code>.</p>
<p>This method mutates the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = fill_empty(df, column_names=[col1, col2], value=0)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    df = pd.DataFrame(...).fill_empty(column_names=col1, value=0)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[str, Iterable[str], Hashable]</code></td>
        <td><p>column_names: A column name or an iterable (list or tuple) of column names. If a single column name is passed in, then only that column will be filled; if a list or tuple is passed in, then those columns will all be filled with the same value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>value</code></td>
        <td></td>
        <td><p>The value that replaces the <code>NaN</code> values.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with <code>NaN</code> values filled.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/fill.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names")
def fill_empty(
    df: pd.DataFrame, column_names: Union[str, Iterable[str], Hashable], value
) -&gt; pd.DataFrame:
    """
    Fill `NaN` values in specified columns with a given value.

    Super sugary syntax that wraps `pandas.DataFrame.fillna`.

    This method mutates the original DataFrame.

    Functional usage syntax:

    ```python
        df = fill_empty(df, column_names=[col1, col2], value=0)
    ```

    Method chaining syntax:

    ```python
        import pandas as pd
        import janitor
        df = pd.DataFrame(...).fill_empty(column_names=col1, value=0)
    ```

    :param df: A pandas DataFrame.
    :param column_names: column_names: A column name or an iterable (list
        or tuple) of column names. If a single column name is passed in, then
        only that column will be filled; if a list or tuple is passed in, then
        those columns will all be filled with the same value.
    :param value: The value that replaces the `NaN` values.
    :returns: A pandas DataFrame with `NaN` values filled.
    """
    check_column(df, column_names)
    return _fill_empty(df, column_names, value=value)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>




  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.filter" class="doc doc-heading">
        <code>filter</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.filter.filter_column_isin" class="doc doc-heading">
<code class="highlight language-python">filter_column_isin(df, column_name, iterable, complement=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Filter a dataframe for values in a column that exist in another iterable.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Assumes exact matching; fuzzy matching not implemented.</p>
<p>The below example syntax will filter the DataFrame such that we only get
rows for which the <code>names</code> are exactly <code>James</code> and <code>John</code>.</p>
<pre><code class="language-python">    df = (
        pd.DataFrame(...)
        .clean_names()
        .filter_column_isin(column_name=&quot;names&quot;, iterable=[&quot;James&quot;, &quot;John&quot;]
        )
    )
</code></pre>
<p>This is the method chaining alternative to:</p>
<pre><code class="language-python">    df = df[df['names'].isin(['James', 'John'])]
</code></pre>
<p>If <code>complement</code> is <code>True</code>, then we will only get rows for which the names
are not <code>James</code> or <code>John</code>.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The column on which to filter.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>iterable</code></td>
        <td><code>Iterable</code></td>
        <td><p>An iterable. Could be a list, tuple, another pandas Series.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>complement</code></td>
        <td><code>bool</code></td>
        <td><p>Whether to return the complement of the selection or not.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A filtered pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>iterable</code> does not have a length of <code>1</code> or greater.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/filter.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def filter_column_isin(
    df: pd.DataFrame,
    column_name: Hashable,
    iterable: Iterable,
    complement: bool = False,
) -&gt; pd.DataFrame:
    """
    Filter a dataframe for values in a column that exist in another iterable.

    This method does not mutate the original DataFrame.

    Assumes exact matching; fuzzy matching not implemented.

    The below example syntax will filter the DataFrame such that we only get
    rows for which the `names` are exactly `James` and `John`.

    ```python
        df = (
            pd.DataFrame(...)
            .clean_names()
            .filter_column_isin(column_name="names", iterable=["James", "John"]
            )
        )
    ```

    This is the method chaining alternative to:

    ```python
        df = df[df['names'].isin(['James', 'John'])]
    ```

    If `complement` is `True`, then we will only get rows for which the names
    are not `James` or `John`.

    :param df: A pandas DataFrame
    :param column_name: The column on which to filter.
    :param iterable: An iterable. Could be a list, tuple, another pandas
        Series.
    :param complement: Whether to return the complement of the selection or
        not.
    :returns: A filtered pandas DataFrame.
    :raises ValueError: if `iterable` does not have a length of `1`
        or greater.
    """
    if len(iterable) == 0:
        raise ValueError(
            "`iterable` kwarg must be given an iterable of length 1 or greater"
        )
    criteria = df[column_name].isin(iterable)

    if complement:
        return df[~criteria]
    return df[criteria]
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.filter.filter_date" class="doc doc-heading">
<code class="highlight language-python">filter_date(df, column_name, start_date=None, end_date=None, years=None, months=None, days=None, column_date_options=None, format=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Filter a date-based column based on certain criteria.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Dates may be finicky and this function builds on top of the <em>magic</em> from
the pandas <code>to_datetime</code> function that is able to parse dates well.</p>
<p>Additional options to parse the date type of your column may be found at
the official pandas <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html">documentation</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method will cast your column to a Timestamp!</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This only affects the format of the <code>start_date</code> and <code>end_date</code>
parameters. If there's an issue with the format of the DataFrame being
parsed, you would pass <code>{'format': your_format}</code> to <code>column_date_options</code>.</p>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The dataframe to filter on.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The column which to apply the fraction transformation.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>start_date</code></td>
        <td><code>Optional[datetime.date]</code></td>
        <td><p>The beginning date to use to filter the DataFrame.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>end_date</code></td>
        <td><code>Optional[datetime.date]</code></td>
        <td><p>The end date to use to filter the DataFrame.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>years</code></td>
        <td><code>Optional[List]</code></td>
        <td><p>The years to use to filter the DataFrame.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>months</code></td>
        <td><code>Optional[List]</code></td>
        <td><p>The months to use to filter the DataFrame.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>days</code></td>
        <td><code>Optional[List]</code></td>
        <td><p>The days to use to filter the DataFrame.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>column_date_options</code></td>
        <td><code>Optional[Dict]</code></td>
        <td><p>'Special options to use when parsing the date column in the original DataFrame. The options may be found at the official Pandas documentation.'</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>format</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>'If you're using a format for <code>start_date</code> or <code>end_date</code> that is not recognized natively by pandas' <code>to_datetime</code> function, you may supply the format yourself. Python date and time formats may be found at <a href="http://strftime.org/">link</a>.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A filtered pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/filter.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name", start="start_date", end="end_date")
def filter_date(
    df: pd.DataFrame,
    column_name: Hashable,
    start_date: Optional[dt.date] = None,
    end_date: Optional[dt.date] = None,
    years: Optional[List] = None,
    months: Optional[List] = None,
    days: Optional[List] = None,
    column_date_options: Optional[Dict] = None,
    format: Optional[str] = None,  # skipcq: PYL-W0622
) -&gt; pd.DataFrame:
    """
    Filter a date-based column based on certain criteria.

    This method does not mutate the original DataFrame.

    Dates may be finicky and this function builds on top of the *magic* from
    the pandas `to_datetime` function that is able to parse dates well.

    Additional options to parse the date type of your column may be found at
    the official pandas [documentation][datetime]

    [datetime]: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html

    !!!note

        This method will cast your column to a Timestamp!

    !!!note

        This only affects the format of the `start_date` and `end_date`
        parameters. If there's an issue with the format of the DataFrame being
        parsed, you would pass `{'format': your_format}` to `column_date_options`.

    :param df: The dataframe to filter on.
    :param column_name: The column which to apply the fraction transformation.
    :param start_date: The beginning date to use to filter the DataFrame.
    :param end_date: The end date to use to filter the DataFrame.
    :param years: The years to use to filter the DataFrame.
    :param months: The months to use to filter the DataFrame.
    :param days: The days to use to filter the DataFrame.
    :param column_date_options: 'Special options to use when parsing the date
        column in the original DataFrame. The options may be found at the
        official Pandas documentation.'
    :param format: 'If you're using a format for `start_date` or `end_date`
        that is not recognized natively by pandas' `to_datetime` function, you
        may supply the format yourself. Python date and time formats may be
        found at [link](http://strftime.org/).
    :returns: A filtered pandas DataFrame.
    """  # noqa: E501

    def _date_filter_conditions(conditions):
        """Taken from: https://stackoverflow.com/a/13616382."""
        return reduce(np.logical_and, conditions)

    if column_date_options:
        df.loc[:, column_name] = pd.to_datetime(
            df.loc[:, column_name], **column_date_options
        )
    else:
        df.loc[:, column_name] = pd.to_datetime(df.loc[:, column_name])

    _filter_list = []

    if start_date:
        start_date = pd.to_datetime(start_date, format=format)
        _filter_list.append(df.loc[:, column_name] &gt;= start_date)

    if end_date:
        end_date = pd.to_datetime(end_date, format=format)
        _filter_list.append(df.loc[:, column_name] &lt;= end_date)

    if years:
        _filter_list.append(df.loc[:, column_name].dt.year.isin(years))

    if months:
        _filter_list.append(df.loc[:, column_name].dt.month.isin(months))

    if days:
        _filter_list.append(df.loc[:, column_name].dt.day.isin(days))

    if start_date and end_date and start_date &gt; end_date:
        warnings.warn(
            f"Your start date of {start_date} is after your end date of "
            f"{end_date}. Is this intended?"
        )

    return df.loc[_date_filter_conditions(_filter_list), :]
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.filter.filter_on" class="doc doc-heading">
<code class="highlight language-python">filter_on(df, criteria, complement=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Return a dataframe filtered on a particular criteria.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>This is super-sugary syntax that wraps the pandas <code>.query()</code> API, enabling
users to use strings to quickly specify filters for filtering their
dataframe. The intent is that <code>filter_on</code> as a verb better matches the
intent of a pandas user than the verb <code>query</code>.</p>
<p>Let's say we wanted to filter students based on whether they failed an exam
or not, which is defined as their score (in the "score" column) being less
than 50.</p>
<pre><code class="language-python">    df = (pd.DataFrame(...)
          .filter_on('score &lt; 50', complement=False)
          ...)  # chain on more data preprocessing.
</code></pre>
<p>This stands in contrast to the in-place syntax that is usually used:</p>
<pre><code class="language-python">    df = pd.DataFrame(...)
    df = df[df['score'] &lt; 3]
</code></pre>
<p>As with the <code>filter_string</code> function, a more seamless flow can be expressed
in the code.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = filter_on(df,
                   'score &lt; 50',
                   complement=False)
</code></pre>
<p>Method chaining syntax:
          .filter_on('score &lt; 50', complement=False))
```</p>
<p>Credit to Brant Peterson for the name.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>criteria</code></td>
        <td><code>str</code></td>
        <td><p>A filtering criteria that returns an array or Series of booleans, on which pandas can filter on.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>complement</code></td>
        <td><code>bool</code></td>
        <td><p>Whether to return the complement of the filter or not.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A filtered pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/filter.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def filter_on(
    df: pd.DataFrame, criteria: str, complement: bool = False
) -&gt; pd.DataFrame:
    """
    Return a dataframe filtered on a particular criteria.

    This method does not mutate the original DataFrame.

    This is super-sugary syntax that wraps the pandas `.query()` API, enabling
    users to use strings to quickly specify filters for filtering their
    dataframe. The intent is that `filter_on` as a verb better matches the
    intent of a pandas user than the verb `query`.

    Let's say we wanted to filter students based on whether they failed an exam
    or not, which is defined as their score (in the "score" column) being less
    than 50.

    ```python
        df = (pd.DataFrame(...)
              .filter_on('score &lt; 50', complement=False)
              ...)  # chain on more data preprocessing.
    ```

    This stands in contrast to the in-place syntax that is usually used:

    ```python
        df = pd.DataFrame(...)
        df = df[df['score'] &lt; 3]
    ```

    As with the `filter_string` function, a more seamless flow can be expressed
    in the code.

    Functional usage syntax:

    ```python
        df = filter_on(df,
                       'score &lt; 50',
                       complement=False)
    ```

    Method chaining syntax:
              .filter_on('score &lt; 50', complement=False))
    ```

    Credit to Brant Peterson for the name.

    :param df: A pandas DataFrame.
    :param criteria: A filtering criteria that returns an array or Series of
        booleans, on which pandas can filter on.
    :param complement: Whether to return the complement of the filter or not.
    :returns: A filtered pandas DataFrame.
    """
    if complement:
        return df.query("not " + criteria)
    return df.query(criteria)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.filter.filter_string" class="doc doc-heading">
<code class="highlight language-python">filter_string(df, column_name, search_string, complement=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Filter a string-based column according to whether it contains a substring.</p>
<p>This is super sugary syntax that builds on top of
<code>pandas.Series.str.contains</code>.</p>
<p>Because this uses internally <code>pandas.Series.str.contains</code>, which allows a
regex string to be passed into it, thus <code>search_string</code> can also be a regex
pattern.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>This function allows us to method chain filtering operations:</p>
<pre><code class="language-python">    df = (pd.DataFrame(...)
          .filter_string('column', search_string='pattern', complement=False)
          ...)  # chain on more data preprocessing.
</code></pre>
<p>This stands in contrast to the in-place syntax that is usually used:</p>
<pre><code class="language-python">    df = pd.DataFrame(...)
    df = df[df['column'].str.contains('pattern')]]
</code></pre>
<p>As can be seen here, the API design allows for a more seamless flow in
expressing the filtering operations.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = filter_string(df,
                       column_name='column',
                       search_string='pattern',
                       complement=False)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    df = (pd.DataFrame(...)

          .filter_string(column_name='column',
                         search_string='pattern',
                         complement=False)
          ...)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The column to filter. The column should contain strings.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>search_string</code></td>
        <td><code>str</code></td>
        <td><p>A regex pattern or a (sub-)string to search.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>complement</code></td>
        <td><code>bool</code></td>
        <td><p>Whether to return the complement of the filter or not.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A filtered pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/filter.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def filter_string(
    df: pd.DataFrame,
    column_name: Hashable,
    search_string: str,
    complement: bool = False,
) -&gt; pd.DataFrame:
    """
    Filter a string-based column according to whether it contains a substring.

    This is super sugary syntax that builds on top of
    `pandas.Series.str.contains`.

    Because this uses internally `pandas.Series.str.contains`, which allows a
    regex string to be passed into it, thus `search_string` can also be a regex
    pattern.

    This method does not mutate the original DataFrame.

    This function allows us to method chain filtering operations:

    ```python
        df = (pd.DataFrame(...)
              .filter_string('column', search_string='pattern', complement=False)
              ...)  # chain on more data preprocessing.
    ```

    This stands in contrast to the in-place syntax that is usually used:

    ```python
        df = pd.DataFrame(...)
        df = df[df['column'].str.contains('pattern')]]
    ```

    As can be seen here, the API design allows for a more seamless flow in
    expressing the filtering operations.

    Functional usage syntax:

    ```python
        df = filter_string(df,
                           column_name='column',
                           search_string='pattern',
                           complement=False)
    ```

    Method chaining syntax:

    ```python
        df = (pd.DataFrame(...)

              .filter_string(column_name='column',
                             search_string='pattern',
                             complement=False)
              ...)
    ```

    :param df: A pandas DataFrame.
    :param column_name: The column to filter. The column should contain strings.
    :param search_string: A regex pattern or a (sub-)string to search.
    :param complement: Whether to return the complement of the filter or not.
    :returns: A filtered pandas DataFrame.
    """  # noqa: E501
    criteria = df[column_name].str.contains(search_string)
    if complement:
        return df[~criteria]
    return df[criteria]
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.find_replace" class="doc doc-heading">
        <code>find_replace</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.find_replace.find_replace" class="doc doc-heading">
<code class="highlight language-python">find_replace(df, match='exact', **mappings)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Perform a find-and-replace action on provided columns.</p>
<p>Depending on use case, users can choose either exact, full-value matching,
or regular-expression-based fuzzy matching
(hence allowing substring matching in the latter case).
For strings, the matching is always case sensitive.</p>
<p>For instance, given a DataFrame containing orders at a coffee shop:</p>
<pre><code class="language-python">    df = pd.DataFrame({
        'customer': ['Mary', 'Tom', 'Lila'],
        'order': ['ice coffee', 'lemonade', 'regular coffee']
    })

    df

        customer         order
    0     Mary      ice coffee
    1      Tom        lemonade
    2     Lila  regular coffee
</code></pre>
<p>Our task is to replace values <code>ice coffee</code> and <code>regular coffee</code>
of the <code>order</code> column into <code>latte</code>.</p>
<p>Example 1 for exact matching</p>
<pre><code class="language-python">    #Functional usage
    df = find_replace(
        df,
        match='exact',
        order={'ice coffee': 'latte', 'regular coffee': 'latte'},
    )
</code></pre>
<pre><code class="language-python">    # Method chaining usage
    df = df.find_replace(
        match='exact'
        order={'ice coffee': 'latte', 'regular coffee': 'latte'},
    )
</code></pre>
<p>Example 2: Regular-expression-based matching</p>
<pre><code class="language-python">    # Functional usage
    df = find_replace(
        df,
        match='regex',
        order={'coffee$': 'latte'},
    )
</code></pre>
<pre><code class="language-python">    # Method chaining usage
    df = df.find_replace(
        match='regex',
        order={'coffee$': 'latte'},
    )
</code></pre>
<p>To perform a find and replace on the entire DataFrame,
pandas' <code>df.replace()</code> function provides the appropriate functionality.
You can find more detail on the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html">replace</a> docs.</p>
<p>This function only works with column names that have no spaces
or punctuation in them.
For example, a column name <code>item_name</code> would work with <code>find_replace</code>,
because it is a contiguous string that can be parsed correctly,
but <code>item name</code> would not be parsed correctly by the Python interpreter.</p>
<p>If you have column names that might not be compatible,
we recommend calling on <code>clean_names()</code> as the first method call.
If, for whatever reason, that is not possible,
then <code>_find_replace</code> is available as a function
that you can do a pandas <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pipe.html">pipe</a> call on.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>match</code></td>
        <td><code>str</code></td>
        <td><p>Whether or not to perform an exact match or not. Valid values are "exact" or "regex".</p></td>
        <td><code>&#39;exact&#39;</code></td>
      </tr>
      <tr>
        <td><code>mappings</code></td>
        <td></td>
        <td><p>keyword arguments corresponding to column names that have dictionaries passed in indicating what to find (keys) and what to replace with (values).</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with replaced values.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/find_replace.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def find_replace(
    df: pd.DataFrame, match: str = "exact", **mappings
) -&gt; pd.DataFrame:
    """
    Perform a find-and-replace action on provided columns.

    Depending on use case, users can choose either exact, full-value matching,
    or regular-expression-based fuzzy matching
    (hence allowing substring matching in the latter case).
    For strings, the matching is always case sensitive.

    For instance, given a DataFrame containing orders at a coffee shop:

    ```python
        df = pd.DataFrame({
            'customer': ['Mary', 'Tom', 'Lila'],
            'order': ['ice coffee', 'lemonade', 'regular coffee']
        })

        df

            customer         order
        0     Mary      ice coffee
        1      Tom        lemonade
        2     Lila  regular coffee
    ```

    Our task is to replace values `ice coffee` and `regular coffee`
    of the `order` column into `latte`.

    Example 1 for exact matching

    ```python
        #Functional usage
        df = find_replace(
            df,
            match='exact',
            order={'ice coffee': 'latte', 'regular coffee': 'latte'},
        )
    ```

    ```python
        # Method chaining usage
        df = df.find_replace(
            match='exact'
            order={'ice coffee': 'latte', 'regular coffee': 'latte'},
        )
    ```

    Example 2: Regular-expression-based matching

    ```python
        # Functional usage
        df = find_replace(
            df,
            match='regex',
            order={'coffee$': 'latte'},
        )
    ```

    ```python
        # Method chaining usage
        df = df.find_replace(
            match='regex',
            order={'coffee$': 'latte'},
        )
    ```

    To perform a find and replace on the entire DataFrame,
    pandas' `df.replace()` function provides the appropriate functionality.
    You can find more detail on the [replace] docs.

    [replace]: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html

    This function only works with column names that have no spaces
    or punctuation in them.
    For example, a column name `item_name` would work with `find_replace`,
    because it is a contiguous string that can be parsed correctly,
    but `item name` would not be parsed correctly by the Python interpreter.

    If you have column names that might not be compatible,
    we recommend calling on `clean_names()` as the first method call.
    If, for whatever reason, that is not possible,
    then `_find_replace` is available as a function
    that you can do a pandas [pipe](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pipe.html) call on.

    :param df: A pandas DataFrame.
    :param match: Whether or not to perform an exact match or not.
        Valid values are "exact" or "regex".
    :param mappings: keyword arguments corresponding to column names
        that have dictionaries passed in indicating what to find (keys)
        and what to replace with (values).
    :returns: A pandas DataFrame with replaced values.
    """  # noqa: E501
    for column_name, mapper in mappings.items():
        df = _find_replace(df, column_name, mapper, match=match)
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.flag_nulls" class="doc doc-heading">
        <code>flag_nulls</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.flag_nulls.flag_nulls" class="doc doc-heading">
<code class="highlight language-python">flag_nulls(df, column_name='null_flag', columns=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Creates a new column to indicate whether you have null values in a given
row. If the columns parameter is not set, looks across the entire
DataFrame, otherwise will look only in the columns you set.</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

df = pd.DataFrame(
    {'a': [1, 2, None, 4],
        'b': [5.0, None, 7.0, 8.0]})

df.flag_nulls()

jn.functions.flag_nulls(df)

df.flag_nulls(columns=['b'])
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>Input Pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Optional[Hashable]</code></td>
        <td><p>Name for the output column. Defaults to 'null_flag'.</p></td>
        <td><code>&#39;null_flag&#39;</code></td>
      </tr>
      <tr>
        <td><code>columns</code></td>
        <td><code>Union[str, Iterable[str], Hashable]</code></td>
        <td><p>List of columns to look at for finding null values. If you only want to look at one column, you can simply give its name. If set to None (default), all DataFrame columns are used.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>Input dataframe with the null flag column.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>column_name</code> is already present in the DataFrame.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if a column within <code>columns</code> is no present in the DataFrame.  .. # noqa: DAR402</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/flag_nulls.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def flag_nulls(
    df: pd.DataFrame,
    column_name: Optional[Hashable] = "null_flag",
    columns: Optional[Union[str, Iterable[str], Hashable]] = None,
) -&gt; pd.DataFrame:
    """Creates a new column to indicate whether you have null values in a given
    row. If the columns parameter is not set, looks across the entire
    DataFrame, otherwise will look only in the columns you set.

    ```python
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(
        {'a': [1, 2, None, 4],
            'b': [5.0, None, 7.0, 8.0]})

    df.flag_nulls()

    jn.functions.flag_nulls(df)

    df.flag_nulls(columns=['b'])
    ```

    :param df: Input Pandas dataframe.
    :param column_name: Name for the output column. Defaults to 'null_flag'.
    :param columns: List of columns to look at for finding null values. If you
        only want to look at one column, you can simply give its name. If set
        to None (default), all DataFrame columns are used.
    :returns: Input dataframe with the null flag column.
    :raises ValueError: if `column_name` is already present in the
        DataFrame.
    :raises ValueError: if a column within `columns` is no present in
        the DataFrame.

    .. # noqa: DAR402
    """
    # Sort out columns input
    if isinstance(columns, str):
        columns = [columns]
    elif columns is None:
        columns = df.columns
    elif not isinstance(columns, Iterable):
        # catches other hashable types
        columns = [columns]

    # Input sanitation checks
    check_column(df, columns)
    check_column(df, [column_name], present=False)

    # This algorithm works best for n_rows &gt;&gt; n_cols. See issue #501
    null_array = np.zeros(len(df))
    for col in columns:
        null_array = np.logical_or(null_array, pd.isna(df[col]))

    df = df.copy()
    df[column_name] = null_array.astype(int)
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.get_dupes" class="doc doc-heading">
        <code>get_dupes</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.get_dupes.get_dupes" class="doc doc-heading">
<code class="highlight language-python">get_dupes(df, column_names=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Return all duplicate rows.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = pd.DataFrame(...)
df = get_dupes(df)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
df = pd.DataFrame(...).get_dupes()
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[str, Iterable[str], Hashable]</code></td>
        <td><p>(optional) A column name or an iterable (list or tuple) of column names. Following pandas API, this only considers certain columns for identifying duplicates. Defaults to using all columns.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>The duplicate rows, as a pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/get_dupes.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names")
def get_dupes(
    df: pd.DataFrame,
    column_names: Optional[Union[str, Iterable[str], Hashable]] = None,
) -&gt; pd.DataFrame:
    """
    Return all duplicate rows.

    This method does not mutate the original DataFrame.

    Functional usage syntax:

    ```python
    df = pd.DataFrame(...)
    df = get_dupes(df)
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    df = pd.DataFrame(...).get_dupes()
    ```

    :param df: The pandas DataFrame object.
    :param column_names: (optional) A column name or an iterable
        (list or tuple) of column names. Following pandas API, this only
        considers certain columns for identifying duplicates. Defaults to using
        all columns.
    :returns: The duplicate rows, as a pandas DataFrame.
    """
    dupes = df.duplicated(subset=column_names, keep=False)
    return df[dupes == True]  # noqa: E712
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.groupby_agg" class="doc doc-heading">
        <code>groupby_agg</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.groupby_agg.groupby_agg" class="doc doc-heading">
<code class="highlight language-python">groupby_agg(df, by, new_column_name, agg_column_name, agg, dropna=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Shortcut for assigning a groupby-transform to a new column.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Without this function, we would have to write a verbose line:</p>
<pre class="highlight"><code>df = df.assign(...=df.groupby(...)[...].transform(...))
</code></pre>
<p>Now, this function can be method-chained:</p>
<pre class="highlight"><code>import pandas as pd
import janitor
df = pd.DataFrame(...).groupby_agg(by='group',
                                   agg='mean',
                                   agg_column_name="col1"
                                   new_column_name='col1_mean_by_group',
                                   dropna = True/False)
</code></pre>
<p>Examples::</p>
<pre class="highlight"><code>import pandas as pd
import janitor as jn

    group  var1
0      1     1
1      1     1
2      1     1
3      1     1
4      1     2
5      2     1
6      2     2
7      2     2
8      2     2
9      2     3
</code></pre>
<p>Let's get the count per <code>group</code> and <code>var1</code>::</p>
<pre class="highlight"><code>df.groupby_agg(
    by = ['group', 'var1'],
    agg = 'size',
    agg_column_name = 'var1',
    new_column_name = 'count'
)

    group  var1  size
0      1     1     4
1      1     1     4
2      1     1     4
3      1     1     4
4      1     2     1
5      2     1     1
6      2     2     3
7      2     2     3
8      2     2     3
9      2     3     1
</code></pre>
<p>If the data has null values,
you can include the null values by passing <code>False</code> to <code>dropna</code>;
this feature was introduced in Pandas 1.1::</p>
<pre class="highlight"><code>    name   type  num  nulls
0  black  chair    4    1.0
1  black  chair    5    1.0
2  black   sofa   12    NaN
3    red   sofa    4    NaN
4    red  plate    3    3.0
</code></pre>
<p>Let's get the count, including the null values,
grouping on <code>nulls</code> column::</p>
<pre class="highlight"><code>df.groupby_agg(
    by="nulls",
    new_column_name="num_count",
    agg_column_name="num",
    agg="size",
    dropna=False,
)

    name   type  num  nulls  num_count
0  black  chair    4    1.0          2
1  black  chair    5    1.0          2
2  black   sofa   12    NaN          2
3    red   sofa    4    NaN          2
4    red  plate    3    3.0          1


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>by</code></td>
        <td><code>Union[List, str]</code></td>
        <td><p>Column(s) to groupby on, either a <code>str</code> or a <code>list</code> of <code>str</code></p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>new_column_name</code></td>
        <td><code>str</code></td>
        <td><p>Name of the aggregation output column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>agg_column_name</code></td>
        <td><code>str</code></td>
        <td><p>Name of the column to aggregate over.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>agg</code></td>
        <td><code>Union[Callable, str]</code></td>
        <td><p>How to aggregate.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dropna</code></td>
        <td><code>bool</code></td>
        <td><p>Whether or not to include null values, if present in the <code>by</code> column(s). Default is True.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/groupby_agg.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(new_column="new_column_name", agg_column="agg_column_name")
def groupby_agg(
    df: pd.DataFrame,
    by: Union[List, str],
    new_column_name: str,
    agg_column_name: str,
    agg: Union[Callable, str],
    dropna: bool = True,
) -&gt; pd.DataFrame:
    """
    Shortcut for assigning a groupby-transform to a new column.

    This method does not mutate the original DataFrame.

    Without this function, we would have to write a verbose line:



        df = df.assign(...=df.groupby(...)[...].transform(...))

    Now, this function can be method-chained:



        import pandas as pd
        import janitor
        df = pd.DataFrame(...).groupby_agg(by='group',
                                           agg='mean',
                                           agg_column_name="col1"
                                           new_column_name='col1_mean_by_group',
                                           dropna = True/False)

    Examples::

        import pandas as pd
        import janitor as jn

            group  var1
        0      1     1
        1      1     1
        2      1     1
        3      1     1
        4      1     2
        5      2     1
        6      2     2
        7      2     2
        8      2     2
        9      2     3

    Let's get the count per `group` and `var1`::

        df.groupby_agg(
            by = ['group', 'var1'],
            agg = 'size',
            agg_column_name = 'var1',
            new_column_name = 'count'
        )

            group  var1  size
        0      1     1     4
        1      1     1     4
        2      1     1     4
        3      1     1     4
        4      1     2     1
        5      2     1     1
        6      2     2     3
        7      2     2     3
        8      2     2     3
        9      2     3     1

    If the data has null values,
    you can include the null values by passing `False` to `dropna`;
    this feature was introduced in Pandas 1.1::

            name   type  num  nulls
        0  black  chair    4    1.0
        1  black  chair    5    1.0
        2  black   sofa   12    NaN
        3    red   sofa    4    NaN
        4    red  plate    3    3.0

    Let's get the count, including the null values,
    grouping on `nulls` column::

        df.groupby_agg(
            by="nulls",
            new_column_name="num_count",
            agg_column_name="num",
            agg="size",
            dropna=False,
        )

            name   type  num  nulls  num_count
        0  black  chair    4    1.0          2
        1  black  chair    5    1.0          2
        2  black   sofa   12    NaN          2
        3    red   sofa    4    NaN          2
        4    red  plate    3    3.0          1

    :param df: A pandas DataFrame.
    :param by: Column(s) to groupby on, either a `str` or
               a `list` of `str`
    :param new_column_name: Name of the aggregation output column.
    :param agg_column_name: Name of the column to aggregate over.
    :param agg: How to aggregate.
    :param dropna: Whether or not to include null values,
        if present in the `by` column(s). Default is True.
    :returns: A pandas DataFrame.
    """
    df = df.copy()

    df[new_column_name] = df.groupby(by, dropna=dropna)[
        agg_column_name
    ].transform(agg)
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.groupby_topk" class="doc doc-heading">
        <code>groupby_topk</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.groupby_topk.groupby_topk" class="doc doc-heading">
<code class="highlight language-python">groupby_topk(df, groupby_column_name, sort_column_name, k, sort_values_kwargs=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Return top <code>k</code> rows from a groupby of a set of columns.</p>
<p>Returns a DataFrame that has the top <code>k</code> values grouped by <code>groupby_column_name</code>
and sorted by <code>sort_column_name</code>.
Additional parameters to the sorting (such as <code>ascending=True</code>)
can be passed using <code>sort_values_kwargs</code>.</p>
<p>List of all sort_values() parameters can be found
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html">here</a>.</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

       age  ID result
    0   20   1   pass
    1   22   2   fail
    2   24   3   pass
    3   23   4   pass
    4   21   5   fail
    5   22   6   pass
</code></pre>
<p>Ascending top 3:</p>
<pre><code class="language-python">    df.groupby_topk('result', 'age', 3)

                age  ID result
    result
    fail    4   21   5   fail
            1   22   2   fail
    pass    0   20   1   pass
            5   22   6   pass
            3   23   4   pass
</code></pre>
<p>Descending top 2:</p>
<pre><code class="language-python">    df.groupby_topk('result', 'age', 2, {'ascending':False})

                age  ID result
    result
    fail    1   22   2   fail
            4   21   5   fail
    pass    2   24   3   pass
            3   23   4   pass
</code></pre>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)
    df = jn.groupby_topk(
        df = df,
        groupby_column_name = 'groupby_column',
        sort_column_name = 'sort_column',
        k = 5
        )
</code></pre>
<p>Method-chaining usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = (
        pd.DataFrame(...)
        .groupby_topk(
        df = df,
        groupby_column_name = 'groupby_column',
        sort_column_name = 'sort_column',
        k = 5
        )
    )
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>groupby_column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Column name to group input DataFrame <code>df</code> by.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sort_column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Name of the column to sort along the input DataFrame <code>df</code>.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>k</code></td>
        <td><code>int</code></td>
        <td><p>Number of top rows to return from each group after sorting.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sort_values_kwargs</code></td>
        <td><code>Dict</code></td>
        <td><p>Arguments to be passed to sort_values function.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with top <code>k</code> rows that are grouped by <code>groupby_column_name</code> column with each group sorted along the column <code>sort_column_name</code>.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>k</code> is less than 1.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>groupby_column_name</code> not in DataFrame <code>df</code>.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>sort_column_name</code> not in DataFrame <code>df</code>.</p></td>
      </tr>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>if <code>inplace:True</code> is present in <code>sort_values_kwargs</code>.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/groupby_topk.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def groupby_topk(
    df: pd.DataFrame,
    groupby_column_name: Hashable,
    sort_column_name: Hashable,
    k: int,
    sort_values_kwargs: Dict = None,
) -&gt; pd.DataFrame:
    """
    Return top `k` rows from a groupby of a set of columns.

    Returns a DataFrame that has the top `k` values grouped by `groupby_column_name`
    and sorted by `sort_column_name`.
    Additional parameters to the sorting (such as `ascending=True`)
    can be passed using `sort_values_kwargs`.

    List of all sort_values() parameters can be found
    [here](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html).


    ```python
        import pandas as pd
        import janitor as jn

           age  ID result
        0   20   1   pass
        1   22   2   fail
        2   24   3   pass
        3   23   4   pass
        4   21   5   fail
        5   22   6   pass
    ```

    Ascending top 3:

    ```python
        df.groupby_topk('result', 'age', 3)

                    age  ID result
        result
        fail    4   21   5   fail
                1   22   2   fail
        pass    0   20   1   pass
                5   22   6   pass
                3   23   4   pass
    ```

    Descending top 2:

    ```python
        df.groupby_topk('result', 'age', 2, {'ascending':False})

                    age  ID result
        result
        fail    1   22   2   fail
                4   21   5   fail
        pass    2   24   3   pass
                3   23   4   pass
    ```

    Functional usage syntax:

    ```python
        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)
        df = jn.groupby_topk(
            df = df,
            groupby_column_name = 'groupby_column',
            sort_column_name = 'sort_column',
            k = 5
            )
    ```

    Method-chaining usage syntax:

    ```python
        import pandas as pd
        import janitor as jn

        df = (
            pd.DataFrame(...)
            .groupby_topk(
            df = df,
            groupby_column_name = 'groupby_column',
            sort_column_name = 'sort_column',
            k = 5
            )
        )
    ```

    :param df: A pandas DataFrame.
    :param groupby_column_name: Column name to group input DataFrame `df` by.
    :param sort_column_name: Name of the column to sort along the
        input DataFrame `df`.
    :param k: Number of top rows to return from each group after sorting.
    :param sort_values_kwargs: Arguments to be passed to sort_values function.
    :returns: A pandas DataFrame with top `k` rows that are grouped by
        `groupby_column_name` column with each group sorted along the
        column `sort_column_name`.
    :raises ValueError: if `k` is less than 1.
    :raises ValueError: if `groupby_column_name` not in DataFrame `df`.
    :raises ValueError: if `sort_column_name` not in DataFrame `df`.
    :raises KeyError: if `inplace:True` is present in `sort_values_kwargs`.
    """  # noqa: E501

    # Convert the default sort_values_kwargs from None to empty Dict
    sort_values_kwargs = sort_values_kwargs or {}

    # Check if groupby_column_name and sort_column_name exists in the DataFrame
    check_column(df, [groupby_column_name, sort_column_name])

    # Check if k is greater than 0.
    if k &lt; 1:
        raise ValueError(
            "Numbers of rows per group to be returned must be greater than 0."
        )

    # Check if inplace:True in sort values kwargs because it returns None
    if (
        "inplace" in sort_values_kwargs.keys()
        and sort_values_kwargs["inplace"]
    ):
        raise KeyError("Cannot use `inplace=True` in `sort_values_kwargs`.")

    return df.groupby(groupby_column_name).apply(
        lambda d: d.sort_values(sort_column_name, **sort_values_kwargs).head(k)
    )
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.impute" class="doc doc-heading">
        <code>impute</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.impute.impute" class="doc doc-heading">
<code class="highlight language-python">impute(df, column_name, value=None, statistic_column_name=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Method-chainable imputation of values in a column.</p>
<p>This method mutates the original DataFrame.</p>
<p>Underneath the hood, this function calls the <code>.fillna()</code> method available
to every <code>pandas.Series</code> object.</p>
<p>Method-chaining example:</p>
<pre><code class="language-python">    import numpy as np
    import pandas as pd
    import janitor

    data = {
        &quot;a&quot;: [1, 2, 3],
        &quot;sales&quot;: np.nan,
        &quot;score&quot;: [np.nan, 3, 2]}
    df = (
        pd.DataFrame(data)
        # Impute null values with 0
        .impute(column_name='sales', value=0.0)
        # Impute null values with median
        .impute(column_name='score', statistic_column_name='median')
    )
</code></pre>
<p>Either one of <code>value</code> or <code>statistic_column_name</code> should be provided.</p>
<p>If <code>value</code> is provided, then all null values in the selected column will
take on the value provided.</p>
<p>If <code>statistic_column_name</code> is provided, then all null values in the
selected column will take on the summary statistic value of other non-null
values.</p>
<p>Currently supported statistics include:</p>
<ul>
<li><code>mean</code> (also aliased by <code>average</code>)</li>
<li><code>median</code></li>
<li><code>mode</code></li>
<li><code>minimum</code> (also aliased by <code>min</code>)</li>
<li><code>maximum</code> (also aliased by <code>max</code>)</li>
</ul>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The name of the column on which to impute values.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>value</code></td>
        <td><code>Optional[Any]</code></td>
        <td><p>(optional) The value to impute.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>statistic_column_name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>(optional) The column statistic to impute.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>An imputed pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if both <code>value</code> and <code>statistic</code> are provided.</p></td>
      </tr>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>if <code>statistic</code> is not one of <code>mean</code>, <code>average</code> <code>median</code>, <code>mode</code>, <code>minimum</code>, <code>min</code>, <code>maximum</code>, or <code>max</code>.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/impute.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
@deprecated_alias(statistic="statistic_column_name")
def impute(
    df: pd.DataFrame,
    column_name: Hashable,
    value: Optional[Any] = None,
    statistic_column_name: Optional[str] = None,
) -&gt; pd.DataFrame:
    """
    Method-chainable imputation of values in a column.

    This method mutates the original DataFrame.

    Underneath the hood, this function calls the `.fillna()` method available
    to every `pandas.Series` object.

    Method-chaining example:

    ```python
        import numpy as np
        import pandas as pd
        import janitor

        data = {
            "a": [1, 2, 3],
            "sales": np.nan,
            "score": [np.nan, 3, 2]}
        df = (
            pd.DataFrame(data)
            # Impute null values with 0
            .impute(column_name='sales', value=0.0)
            # Impute null values with median
            .impute(column_name='score', statistic_column_name='median')
        )
    ```

    Either one of `value` or `statistic_column_name` should be provided.

    If `value` is provided, then all null values in the selected column will
    take on the value provided.

    If `statistic_column_name` is provided, then all null values in the
    selected column will take on the summary statistic value of other non-null
    values.

    Currently supported statistics include:

    - `mean` (also aliased by `average`)
    - `median`
    - `mode`
    - `minimum` (also aliased by `min`)
    - `maximum` (also aliased by `max`)

    :param df: A pandas DataFrame
    :param column_name: The name of the column on which to impute values.
    :param value: (optional) The value to impute.
    :param statistic_column_name: (optional) The column statistic to impute.
    :returns: An imputed pandas DataFrame.
    :raises ValueError: if both `value` and `statistic` are provided.
    :raises KeyError: if `statistic` is not one of `mean`, `average`
        `median`, `mode`, `minimum`, `min`, `maximum`, or `max`.
    """
    # Firstly, we check that only one of `value` or `statistic` are provided.
    if value is not None and statistic_column_name is not None:
        raise ValueError(
            "Only one of `value` or `statistic` should be provided"
        )

    # If statistic is provided, then we compute the relevant summary statistic
    # from the other data.
    funcs = {
        "mean": np.mean,
        "average": np.mean,  # aliased
        "median": np.median,
        "mode": mode,
        "minimum": np.min,
        "min": np.min,  # aliased
        "maximum": np.max,
        "max": np.max,  # aliased
    }
    if statistic_column_name is not None:
        # Check that the statistic keyword argument is one of the approved.
        if statistic_column_name not in funcs.keys():
            raise KeyError(f"`statistic` must be one of {funcs.keys()}")

        value = funcs[statistic_column_name](
            df[column_name].dropna().to_numpy()
        )
        # special treatment for mode, because scipy stats mode returns a
        # moderesult object.
        if statistic_column_name == "mode":
            value = value.mode[0]

    # The code is architected this way - if `value` is not provided but
    # statistic is, we then overwrite the None value taken on by `value`, and
    # use it to set the imputation column.
    if value is not None:
        df[column_name] = df[column_name].fillna(value)
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.jitter" class="doc doc-heading">
        <code>jitter</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.jitter.jitter" class="doc doc-heading">
<code class="highlight language-python">jitter(df, column_name, dest_column_name, scale, clip=None, random_state=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Adds Gaussian noise (jitter) to the values of a column.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

df = pd.DataFrame(...)

df = jn.functions.jitter(
    df=df,
    column_name='values',
    dest_column_name='values_jitter',
    scale=1.0,
    clip=None,
    random_state=None,
)
</code></pre>
<p>Method chaining usage example:</p>
<pre><code>import pandas as pd
import janitor

df = pd.DataFrame(...)

df = df.jitter(
    column_name='values',
    dest_column_name='values_jitter',
    scale=1.0,
    clip=None,
    random_state=None,
)
</code></pre>
<p>A new column will be created containing the values of the original column
with Gaussian noise added.
For each value in the column, a Gaussian distribution is created
having a location (mean) equal to the value
and a scale (standard deviation) equal to <code>scale</code>.
A random value is then sampled from this distribution,
which is the jittered value.
If a tuple is supplied for <code>clip</code>,
then any values of the new column less than <code>clip[0]</code>
will be set to <code>clip[0]</code>,
and any values greater than <code>clip[1]</code> will be set to <code>clip[1]</code>.
Additionally, if a numeric value is supplied for <code>random_state</code>,
this value will be used to set the random seed used for sampling.
NaN values are ignored in this method.</p>
<p>This method mutates the original DataFrame.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Name of the column containing values to add Gaussian jitter to.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dest_column_name</code></td>
        <td><code>str</code></td>
        <td><p>The name of the new column containing the jittered values that will be created.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>scale</code></td>
        <td><code>number</code></td>
        <td><p>A positive value multiplied by the original column value to determine the scale (standard deviation) of the Gaussian distribution to sample from. (A value of zero results in no jittering.)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>clip</code></td>
        <td><code>Optional[Iterable[numpy.number]]</code></td>
        <td><p>An iterable of two values (minimum and maximum) to clip the jittered values to, default to None.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>random_state</code></td>
        <td><code>Optional[numpy.number]</code></td>
        <td><p>An integer or 1-d array value used to set the random seed, default to None.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with a new column containing Gaussian-jittered values from another column.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>if <code>column_name</code> is not numeric.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>scale</code> is not a numerical value greater than <code>0</code>.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>clip</code> is not an iterable of length <code>2</code>.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>clip[0]</code> is not less than <code>clip[1]</code>.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/jitter.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def jitter(
    df: pd.DataFrame,
    column_name: Hashable,
    dest_column_name: str,
    scale: np.number,
    clip: Optional[Iterable[np.number]] = None,
    random_state: Optional[np.number] = None,
) -&gt; pd.DataFrame:
    """
    Adds Gaussian noise (jitter) to the values of a column.

    Functional usage syntax:

    ```python
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)

    df = jn.functions.jitter(
        df=df,
        column_name='values',
        dest_column_name='values_jitter',
        scale=1.0,
        clip=None,
        random_state=None,
    )
    ```

    Method chaining usage example:

    ```
    import pandas as pd
    import janitor

    df = pd.DataFrame(...)

    df = df.jitter(
        column_name='values',
        dest_column_name='values_jitter',
        scale=1.0,
        clip=None,
        random_state=None,
    )
    ```

    A new column will be created containing the values of the original column
    with Gaussian noise added.
    For each value in the column, a Gaussian distribution is created
    having a location (mean) equal to the value
    and a scale (standard deviation) equal to `scale`.
    A random value is then sampled from this distribution,
    which is the jittered value.
    If a tuple is supplied for `clip`,
    then any values of the new column less than `clip[0]`
    will be set to `clip[0]`,
    and any values greater than `clip[1]` will be set to `clip[1]`.
    Additionally, if a numeric value is supplied for `random_state`,
    this value will be used to set the random seed used for sampling.
    NaN values are ignored in this method.

    This method mutates the original DataFrame.

    :param df: A pandas DataFrame.
    :param column_name: Name of the column containing
        values to add Gaussian jitter to.
    :param dest_column_name: The name of the new column containing the
        jittered values that will be created.
    :param scale: A positive value multiplied by the original
        column value to determine the scale (standard deviation) of the
        Gaussian distribution to sample from. (A value of zero results in
        no jittering.)
    :param clip: An iterable of two values (minimum and maximum) to clip
        the jittered values to, default to None.
    :param random_state: An integer or 1-d array value used to set the random
        seed, default to None.

    :returns: A pandas DataFrame with a new column containing
        Gaussian-jittered values from another column.
    :raises TypeError: if `column_name` is not numeric.
    :raises ValueError: if `scale` is not a numerical value
        greater than `0`.
    :raises ValueError: if `clip` is not an iterable of length `2`.
    :raises ValueError: if `clip[0]` is not less than `clip[1]`.
    """

    # Check types
    check("scale", scale, [int, float])

    # Check that `column_name` is a numeric column
    if not np.issubdtype(df[column_name].dtype, np.number):
        raise TypeError(f"{column_name} must be a numeric column.")

    if scale &lt;= 0:
        raise ValueError("`scale` must be a numeric value greater than 0.")
    values = df[column_name]
    if random_state is not None:
        np.random.seed(random_state)
    result = np.random.normal(loc=values, scale=scale)
    if clip:
        # Ensure `clip` has length 2
        if len(clip) != 2:
            raise ValueError("`clip` must be an iterable of length 2.")
        # Ensure the values in `clip` are ordered as min, max
        if clip[1] &lt; clip[0]:
            raise ValueError("`clip[0]` must be less than `clip[1]`.")
        result = np.clip(result, *clip)
    df[dest_column_name] = result

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.join_apply" class="doc doc-heading">
        <code>join_apply</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.join_apply.join_apply" class="doc doc-heading">
<code class="highlight language-python">join_apply(df, func, new_column_name)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Join the result of applying a function across dataframe rows.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>This is a convenience function that allows us to apply arbitrary functions
that take any combination of information from any of the columns. The only
requirement is that the function signature takes in a row from the
DataFrame.</p>
<p>The example below shows us how to sum the result of two columns into a new
column.</p>
<pre><code class="language-python">    df = (
        pd.DataFrame({'a':[1, 2, 3], 'b': [2, 3, 4]})
        .join_apply(lambda x: 2 * x['a'] + x['b'], new_column_name=&quot;2a+b&quot;)
    )
</code></pre>
<p>This following example shows us how to use conditionals in the same
function.</p>
<pre><code class="language-python">    def take_a_if_even(x):
        if x['a'] % 2:
            return x['a']
        else:
            return x['b']

    df = (
        pd.DataFrame({'a': [1, 2, 3], 'b': [2, 3, 4]})
        .join_apply(take_a_if_even, 'a_if_even')
    )
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>func</code></td>
        <td><code>Callable</code></td>
        <td><p>A function that is applied elementwise across all rows of the DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>new_column_name</code></td>
        <td><code>str</code></td>
        <td><p>New column name.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with new column appended.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/join_apply.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def join_apply(
    df: pd.DataFrame, func: Callable, new_column_name: str
) -&gt; pd.DataFrame:
    """
    Join the result of applying a function across dataframe rows.

    This method does not mutate the original DataFrame.

    This is a convenience function that allows us to apply arbitrary functions
    that take any combination of information from any of the columns. The only
    requirement is that the function signature takes in a row from the
    DataFrame.

    The example below shows us how to sum the result of two columns into a new
    column.

    ```python
        df = (
            pd.DataFrame({'a':[1, 2, 3], 'b': [2, 3, 4]})
            .join_apply(lambda x: 2 * x['a'] + x['b'], new_column_name="2a+b")
        )
    ```

    This following example shows us how to use conditionals in the same
    function.

    ```python
        def take_a_if_even(x):
            if x['a'] % 2:
                return x['a']
            else:
                return x['b']

        df = (
            pd.DataFrame({'a': [1, 2, 3], 'b': [2, 3, 4]})
            .join_apply(take_a_if_even, 'a_if_even')
        )
    ```

    :param df: A pandas DataFrame
    :param func: A function that is applied elementwise across all rows of the
        DataFrame.
    :param new_column_name: New column name.
    :returns: A pandas DataFrame with new column appended.
    """
    df = df.copy().join(df.apply(func, axis=1).rename(new_column_name))
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.label_encode" class="doc doc-heading">
        <code>label_encode</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.label_encode.label_encode" class="doc doc-heading">
<code class="highlight language-python">label_encode(df, column_names)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Convert labels into numerical data.</p>
<p>This method will create a new column with the string <code>_enc</code> appended
after the original column's name. Consider this to be syntactic sugar.</p>
<p>This method behaves differently from <code>encode_categorical</code>. This method
creates a new column of numeric data. <code>encode_categorical</code> replaces the
dtype of the original column with a <em>categorical</em> dtype.</p>
<p>This method mutates the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = label_encode(df, column_names=&quot;my_categorical_column&quot;)  # one way
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
categorical_cols = ['col1', 'col2', 'col4']
df = pd.DataFrame(...).label_encode(column_names=categorical_cols)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[str, Iterable[str], Hashable]</code></td>
        <td><p>A column name or an iterable (list or tuple) of column names.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/label_encode.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names")
def label_encode(
    df: pd.DataFrame, column_names: Union[str, Iterable[str], Hashable]
) -&gt; pd.DataFrame:
    """
    Convert labels into numerical data.

    This method will create a new column with the string `_enc` appended
    after the original column's name. Consider this to be syntactic sugar.

    This method behaves differently from `encode_categorical`. This method
    creates a new column of numeric data. `encode_categorical` replaces the
    dtype of the original column with a *categorical* dtype.

    This method mutates the original DataFrame.

    Functional usage syntax:

    ```python
    df = label_encode(df, column_names="my_categorical_column")  # one way
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    categorical_cols = ['col1', 'col2', 'col4']
    df = pd.DataFrame(...).label_encode(column_names=categorical_cols)
    ```

    :param df: The pandas DataFrame object.
    :param column_names: A column name or an iterable (list
        or tuple) of column names.
    :returns: A pandas DataFrame.
    """
    warnings.warn(
        "label_encode will be deprecated in a 1.x release. \
        Please use factorize_columns instead"
    )
    df = _factorize(df, column_names, "_enc")
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.limit_column_characters" class="doc doc-heading">
        <code>limit_column_characters</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.limit_column_characters.limit_column_characters" class="doc doc-heading">
<code class="highlight language-python">limit_column_characters(df, column_length, col_separator='_')</code>


</h3>

    <div class="doc doc-contents ">

      <p>Truncate column sizes to a specific length.</p>
<p>This method mutates the original DataFrame.</p>
<p>Method chaining will truncate all columns to a given length and append
a given separator character with the index of duplicate columns, except
for the first distinct column name.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_length</code></td>
        <td><code>int</code></td>
        <td><p>Character length for which to truncate all columns. The column separator value and number for duplicate column name does not contribute. Therefore, if all columns are truncated to 10 characters, the first distinct column will be 10 characters and the remaining will be 12 characters (assuming a column separator of one character).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>col_separator</code></td>
        <td><code>str</code></td>
        <td><p>The separator to use for counting distinct column values. I think an underscore looks nicest, however a period is a common option as well. Supply an empty string (i.e. '') to remove the separator.</p></td>
        <td><code>&#39;_&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with truncated column lengths.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/limit_column_characters.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def limit_column_characters(
    df: pd.DataFrame, column_length: int, col_separator: str = "_"
) -&gt; pd.DataFrame:
    """Truncate column sizes to a specific length.

    This method mutates the original DataFrame.

    Method chaining will truncate all columns to a given length and append
    a given separator character with the index of duplicate columns, except
    for the first distinct column name.

    :param df: A pandas dataframe.
    :param column_length: Character length for which to truncate all columns.
        The column separator value and number for duplicate column name does
        not contribute. Therefore, if all columns are truncated to 10
        characters, the first distinct column will be 10 characters and the
        remaining will be 12 characters (assuming a column separator of one
        character).
    :param col_separator: The separator to use for counting distinct column
        values. I think an underscore looks nicest, however a period is a
        common option as well. Supply an empty string (i.e. '') to remove the
        separator.
    :returns: A pandas DataFrame with truncated column lengths.
    """
    # :Example Setup:

    # ```python

    #     import pandas as pd
    #     import janitor
    #     data_dict = {
    #         "really_long_name_for_a_column": range(10),
    #         "another_really_long_name_for_a_column": \
    #         [2 * item for item in range(10)],
    #         "another_really_longer_name_for_a_column": list("lllongname"),
    #         "this_is_getting_out_of_hand": list("longername"),
    #     }

    # :Example: Standard truncation:

    # ```python

    #     example_dataframe = pd.DataFrame(data_dict)
    #     example_dataframe.limit_column_characters(7)

    # :Output:

    # ```python

    #            really_  another another_1 this_is
    #     0        0        0         l       l
    #     1        1        2         l       o
    #     2        2        4         l       n
    #     3        3        6         o       g
    #     4        4        8         n       e
    #     5        5       10         g       r
    #     6        6       12         n       n
    #     7        7       14         a       a
    #     8        8       16         m       m
    #     9        9       18         e       e

    # :Example: Standard truncation with different separator character:

    # ```python

    #     example_dataframe2 = pd.DataFrame(data_dict)
    #     example_dataframe2.limit_column_characters(7, ".")

    # ```python

    #            really_  another another.1 this_is
    #     0        0        0         l       l
    #     1        1        2         l       o
    #     2        2        4         l       n
    #     3        3        6         o       g
    #     4        4        8         n       e
    #     5        5       10         g       r
    #     6        6       12         n       n
    #     7        7       14         a       a
    #     8        8       16         m       m
    #     9        9       18         e       e
    check("column_length", column_length, [int])
    check("col_separator", col_separator, [str])

    col_names = df.columns
    col_names = [col_name[:column_length] for col_name in col_names]

    col_name_set = set(col_names)
    col_name_count = {}

    # If no columns are duplicates, we can skip the loops below.
    if len(col_name_set) == len(col_names):
        df.columns = col_names
        return df

    for col_name_to_check in col_name_set:
        count = 0
        for idx, col_name in enumerate(col_names):
            if col_name_to_check == col_name:
                col_name_count[idx] = count
                count += 1

    final_col_names = []
    for idx, col_name in enumerate(col_names):
        if col_name_count[idx] &gt; 0:
            col_name_to_append = (
                col_name + col_separator + str(col_name_count[idx])
            )
            final_col_names.append(col_name_to_append)
        else:
            final_col_names.append(col_name)

    df.columns = final_col_names
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.min_max_scale" class="doc doc-heading">
        <code>min_max_scale</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.min_max_scale.min_max_scale" class="doc doc-heading">
<code class="highlight language-python">min_max_scale(df, old_min=None, old_max=None, column_name=None, new_min=0, new_max=1)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Scales data to between a minimum and maximum value.</p>
<p>This method mutates the original DataFrame.</p>
<p>If <code>minimum</code> and <code>maximum</code> are provided, the true min/max of the
<code>DataFrame</code> or column is ignored in the scaling process and replaced with
these values, instead.</p>
<p>One can optionally set a new target minimum and maximum value using the
<code>new_min</code> and <code>new_max</code> keyword arguments. This will result in the
transformed data being bounded between <code>new_min</code> and <code>new_max</code>.</p>
<p>If a particular column name is specified, then only that column of data
are scaled. Otherwise, the entire dataframe is scaled.</p>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    df = pd.DataFrame(...).min_max_scale(column_name=&quot;a&quot;)
</code></pre>
<p>Setting custom minimum and maximum:</p>
<pre><code class="language-python">    df = (
        pd.DataFrame(...)
        .min_max_scale(
            column_name=&quot;a&quot;,
            new_min=2,
            new_max=10
        )
    )
</code></pre>
<p>Setting a min and max that is not based on the data, while applying to
entire dataframe:</p>
<pre><code class="language-python">    df = (
        pd.DataFrame(...)
        .min_max_scale(
            old_min=0,
            old_max=14,
            new_min=0,
            new_max=1,
        )
    )
</code></pre>
<p>The aforementioned example might be applied to something like scaling the
isoelectric points of amino acids. While technically they range from
approx 3-10, we can also think of them on the pH scale which ranges from
1 to 14. Hence, 3 gets scaled not to 0 but approx. 0.15 instead, while 10
gets scaled to approx. 0.69 instead.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>old_min</code></td>
        <td></td>
        <td><p>(optional) Overrides for the current minimum value of the data to be transformed.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>old_max</code></td>
        <td></td>
        <td><p>(optional) Overrides for the current maximum value of the data to be transformed.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>new_min</code></td>
        <td></td>
        <td><p>(optional) The minimum value of the data after it has been scaled.</p></td>
        <td><code>0</code></td>
      </tr>
      <tr>
        <td><code>new_max</code></td>
        <td></td>
        <td><p>(optional) The maximum value of the data after it has been scaled.</p></td>
        <td><code>1</code></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td></td>
        <td><p>(optional) The column on which to perform scaling.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with scaled data.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>old_max</code> is not greater than `old_min``.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>new_max</code> is not greater than `new_min``.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/min_max_scale.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(col_name="column_name")
def min_max_scale(
    df: pd.DataFrame,
    old_min=None,
    old_max=None,
    column_name=None,
    new_min=0,
    new_max=1,
) -&gt; pd.DataFrame:
    """
    Scales data to between a minimum and maximum value.

    This method mutates the original DataFrame.

    If `minimum` and `maximum` are provided, the true min/max of the
    `DataFrame` or column is ignored in the scaling process and replaced with
    these values, instead.

    One can optionally set a new target minimum and maximum value using the
    `new_min` and `new_max` keyword arguments. This will result in the
    transformed data being bounded between `new_min` and `new_max`.

    If a particular column name is specified, then only that column of data
    are scaled. Otherwise, the entire dataframe is scaled.

    Method chaining syntax:

    ```python
        df = pd.DataFrame(...).min_max_scale(column_name="a")
    ```

    Setting custom minimum and maximum:

    ```python
        df = (
            pd.DataFrame(...)
            .min_max_scale(
                column_name="a",
                new_min=2,
                new_max=10
            )
        )
    ```

    Setting a min and max that is not based on the data, while applying to
    entire dataframe:


    ```python
        df = (
            pd.DataFrame(...)
            .min_max_scale(
                old_min=0,
                old_max=14,
                new_min=0,
                new_max=1,
            )
        )
    ```

    The aforementioned example might be applied to something like scaling the
    isoelectric points of amino acids. While technically they range from
    approx 3-10, we can also think of them on the pH scale which ranges from
    1 to 14. Hence, 3 gets scaled not to 0 but approx. 0.15 instead, while 10
    gets scaled to approx. 0.69 instead.

    :param df: A pandas DataFrame.
    :param old_min: (optional) Overrides for the current minimum
        value of the data to be transformed.
    :param old_max: (optional) Overrides for the current maximum
        value of the data to be transformed.
    :param new_min: (optional) The minimum value of the data after
        it has been scaled.
    :param new_max: (optional) The maximum value of the data after
        it has been scaled.
    :param column_name: (optional) The column on which to perform scaling.
    :returns: A pandas DataFrame with scaled data.
    :raises ValueError: if `old_max` is not greater than `old_min``.
    :raises ValueError: if `new_max` is not greater than `new_min``.
    """
    if (
        (old_min is not None)
        and (old_max is not None)
        and (old_max &lt;= old_min)
    ):
        raise ValueError("`old_max` should be greater than `old_min`")

    if new_max &lt;= new_min:
        raise ValueError("`new_max` should be greater than `new_min`")

    new_range = new_max - new_min

    if column_name:
        if old_min is None:
            old_min = df[column_name].min()
        if old_max is None:
            old_max = df[column_name].max()
        old_range = old_max - old_min
        df[column_name] = (
            df[column_name] - old_min
        ) * new_range / old_range + new_min
    else:
        if old_min is None:
            old_min = df.min().min()
        if old_max is None:
            old_max = df.max().max()
        old_range = old_max - old_min
        df = (df - old_min) * new_range / old_range + new_min
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.move" class="doc doc-heading">
        <code>move</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.move.move" class="doc doc-heading">
<code class="highlight language-python">move(df, source, target, position='before', axis=0)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Move column or row to a position adjacent to another column or row in
dataframe. Must have unique column names or indices.</p>
<p>This operation does not reset the index of the dataframe. User must
explicitly do so.</p>
<p>Does not apply to multilevel dataframes.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = move(df, source=3, target=15, position='after', axis=0)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
df = (
    pd.DataFrame(...)
    .move(source=3, target=15, position='after', axis=0)
)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas Dataframe object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>source</code></td>
        <td><code>Union[int, str]</code></td>
        <td><p>column or row to move</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>target</code></td>
        <td><code>Union[int, str]</code></td>
        <td><p>column or row to move adjacent to</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>position</code></td>
        <td><code>str</code></td>
        <td><p>Specifies whether the Series is moved to before or after the adjacent Series. Values can be either <code>before</code> or <code>after</code>; defaults to <code>before</code>.</p></td>
        <td><code>&#39;before&#39;</code></td>
      </tr>
      <tr>
        <td><code>axis</code></td>
        <td><code>int</code></td>
        <td><p>Axis along which the function is applied. 0 to move a row, 1 to move a column.</p></td>
        <td><code>0</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>The dataframe with the Series moved.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>axis</code> is not <code>0</code> or `1``.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>position</code> is not <code>before</code> or `after``.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if  <code>source</code> row or column is not in dataframe.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>target</code> row or column is not in dataframe.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/move.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def move(
    df: pd.DataFrame,
    source: Union[int, str],
    target: Union[int, str],
    position: str = "before",
    axis: int = 0,
) -&gt; pd.DataFrame:
    """
    Move column or row to a position adjacent to another column or row in
    dataframe. Must have unique column names or indices.

    This operation does not reset the index of the dataframe. User must
    explicitly do so.

    Does not apply to multilevel dataframes.

    Functional usage syntax:

    ```python
    df = move(df, source=3, target=15, position='after', axis=0)
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    df = (
        pd.DataFrame(...)
        .move(source=3, target=15, position='after', axis=0)
    )
    ```

    :param df: The pandas Dataframe object.
    :param source: column or row to move
    :param target: column or row to move adjacent to
    :param position: Specifies whether the Series is moved to before or
        after the adjacent Series. Values can be either `before` or `after`;
        defaults to `before`.
    :param axis: Axis along which the function is applied. 0 to move a
        row, 1 to move a column.
    :returns: The dataframe with the Series moved.
    :raises ValueError: if `axis` is not `0` or `1``.
    :raises ValueError: if `position` is not `before` or `after``.
    :raises ValueError: if  `source` row or column is not in dataframe.
    :raises ValueError: if `target` row or column is not in dataframe.
    """
    df = df.copy()
    if axis not in [0, 1]:
        raise ValueError(f"Invalid axis '{axis}'. Can only be 0 or 1.")

    if position not in ["before", "after"]:
        raise ValueError(
            f"Invalid position '{position}'. Can only be 'before' or 'after'."
        )

    if axis == 0:
        names = list(df.index)

        if source not in names:
            raise ValueError(f"Source row '{source}' not in dataframe.")

        if target not in names:
            raise ValueError(f"Target row '{target}' not in dataframe.")

        names.remove(source)
        pos = names.index(target)

        if position == "after":
            pos += 1
        names.insert(pos, source)

        df = df.loc[names, :]
    else:
        names = list(df.columns)

        if source not in names:
            raise ValueError(f"Source column '{source}' not in dataframe.")

        if target not in names:
            raise ValueError(f"Target column '{target}' not in dataframe.")

        names.remove(source)
        pos = names.index(target)

        if position == "after":
            pos += 1
        names.insert(pos, source)

        df = df.loc[:, names]

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.pivot" class="doc doc-heading">
        <code>pivot</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.pivot.pivot_longer" class="doc doc-heading">
<code class="highlight language-python">pivot_longer(df, index=None, column_names=None, names_to=None, values_to='value', column_level=None, names_sep=None, names_pattern=None, sort_by_appearance=False, ignore_index=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Unpivots a DataFrame from <em>wide</em> to <em>long</em> format.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>It is a wrapper around <code>pd.melt</code> and is meant to serve as a single point
for transformations that require <code>pd.melt</code> or <code>pd.wide_to_long</code>.</p>
<p>It is modeled after the <code>pivot_longer</code> function in R's tidyr package, and
offers more functionality and flexibility than <code>pd.wide_to_long</code>.</p>
<p>This function is useful to massage a DataFrame into a format where
one or more columns are considered measured variables, and all other
columns are considered as identifier variables.</p>
<p>All measured variables are <em>unpivoted</em> (and typically duplicated) along the
row axis.</p>
<p>Example 1: The following DataFrame contains heartrate data for patients
treated with two different drugs, <code>a</code> and <code>b</code>.</p>
<pre><code class="language-python">          name   a   b
    0   Wilbur  67  56
    1  Petunia  80  90
    2  Gregory  64  50
</code></pre>
<p>The column names <code>a</code> and <code>b</code> are actually the names of a measured variable
(i.e. the name of a drug), but the values are a different measured variable
(heartrate). We would like to unpivot these <code>a</code> and <code>b</code> columns into a
<code>drug</code> column and a <code>heartrate</code> column.</p>
<pre><code class="language-python">    df.pivot_longer(
        column_names = ['a', 'b'],
        names_to = 'drug',
        values_to = 'heartrate',
        sort_by_appearance = True
    )


          name drug  heartrate
    0   Wilbur    a         67
    1   Wilbur    b         56
    2  Petunia    a         80
    3  Petunia    b         90
    4  Gregory    a         64
    5  Gregory    b         50
</code></pre>
<p>Note how the data is stacked in order of first appearance. If, however,
you do not care for order of appearance, and want to wring out some
more performance, you can set <code>sort_by_appearance</code> to <code>False</code> (the
default is <code>False</code>).</p>
<pre><code class="language-python">    df.pivot_longer(
        column_names = ['a', 'b'],
        names_to = 'drug',
        values_to = 'heartrate',
        sort_by_appearance = False
    )


            name     drug  heartrate
    0       Wilbur     a    67
    1       Petunia    a    80
    2       Gregory    a    64
    3       Wilbur     b    56
    4       Petunia    b    90
    5       Gregory    b    50
</code></pre>
<p>You can set <code>ignore_index</code> to <code>False</code>, if you wish to reuse the index
from the source DataFrame (the index will be repeated as many times as
necessary):</p>
<pre><code class="language-python">    df.pivot_longer(
        column_names = ['a', 'b'],
        names_to = 'drug',
        values_to = 'heartrate',
        sort_by_appearance = False,
        ignore_index = False
    )


            name     drug  heartrate
    0       Wilbur     a    67
    1       Petunia    a    80
    2       Gregory    a    64
    0       Wilbur     b    56
    1       Petunia    b    90
    2       Gregory    b    50
</code></pre>
<p>MultiIndex DataFrames are unpivoted in the same form that you would
expect from pandas' <code>melt</code>:</p>
<pre><code class="language-python">        A  B  C
        D  E  F
    0   a  1  2
    1   b  3  4
    2   c  5  6

    df.pivot_longer(
        index = [(&quot;A&quot;, &quot;D&quot;)],
        names_to = [&quot;first&quot;, &quot;second&quot;]
    )


         (A, D)  first   second   value
    0       a       B       E       1
    1       b       B       E       3
    2       c       B       E       5
    3       a       C       F       2
    4       b       C       F       4
    5       c       C       F       6
</code></pre>
<p>You can also unpivot on a specific level:</p>
<pre><code class="language-python">    df.pivot_longer(
        index = &quot;A&quot;,
        names_to = &quot;first&quot;,
        column_level = 0
    )


       A      first  value
    0  a        B      1
    1  b        B      3
    2  c        B      5
</code></pre>
<p>Example 2: The DataFrame below has year and month variables embedded within
the column names.</p>
<pre><code class="language-python">          col1          2019-12      2020-01         2020-02
    0       a          -1.085631    -1.506295       -2.426679
    1       b           0.997345    -0.578600       -0.428913
    2       c           0.282978     1.651437        1.265936
</code></pre>
<p><code>pivot_longer</code> can conveniently reshape the DataFrame into long format,
with new columns for the year and month. You simply pass in the new
column names to <code>names_to</code>, and pass the hyphen <code>-</code> to the <code>names_sep</code>
argument.</p>
<pre><code class="language-python">    df.pivot_longer(
        index = 'col1',
        names_to = ('year', 'month'),
        names_sep = '-',
        sort_by_appearance = True
    )

       col1 year   month      value
    0    a  2019     12     -1.085631
    1    a  2020     01     -1.506295
    2    a  2020     02     -2.426679
    3    b  2019     12      0.997345
    4    b  2020     01     -0.578600
    5    b  2020     02     -0.428913
    6    c  2019     12      0.282978
    7    c  2020     01      1.651437
    8    c  2020     02      1.265936
</code></pre>
<p>Example 3: The DataFrame below has names embedded in it
<code>(measure1, measure2)</code> that we would love to reuse as column names.</p>
<pre><code class="language-python">        treat1-measure1     treat1-measure2 treat2-measure1 treat2-measure2
    0                1              4                   2               5
    1                2              5                   3               4
</code></pre>
<p>For this, we use the <code>.value</code> variable, which signals to <code>pivot_longer</code>
to treat the part of the column names corresponding to <code>.value</code> as new
column names. The <code>.value</code> variable is similar to <code>stubnames</code> in pandas'
<code>wide_to_long</code> function, but with more flexibility.</p>
<pre><code class="language-python">    df.pivot_longer(
        names_to = (&quot;group&quot;, '.value'),
        names_sep = '-',
        sort_by_appearance = True
    )


        group  measure1  measure2
    0  treat1         1         4
    1  treat2         2         5
    2  treat1         2         5
    3  treat2         3         4
</code></pre>
<p>Let's break down the <code>.value</code> idea. When <code>.value</code> is used, <code>pivot_longer</code>
creates a pairing. In the example above, we get a pairing
<code>{"group":["treat1", "treat2"], ".value":["measure1", "measure2"]}</code>. All
the values associated with <code>.value</code> become new column names, while those
not associated with <code>.value</code>(<code>treat1</code> and <code>treat2</code>) become values in a
new column <code>group</code>. <code>values_to</code> is overridden during this process.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The values not associated with <code>.value</code> (in the example above,
this is the <code>group</code> column) are returned as object dtypes. You can
change it to your preferred dtype using pandas' <code>astype</code> method.</p>
</div>
<p>Example 4: You can also unpivot from wide to long using regular expressions</p>
<pre><code class="language-python">        n_1  n_2  n_3  pct_1  pct_2  pct_3
    0   10   20   30   0.1    0.2    0.3

    df.pivot_longer(
        names_to = (&quot;.value&quot;, &quot;name&quot;),
        names_pattern = &quot;(.*)_(.)&quot;
     )


        name    n  pct
    0     1  10.0  0.1
    1     2  20.0  0.2
    2     3  30.0  0.3
</code></pre>
<p>The same idea of <code>.value</code> works here as well. Based on the capturing groups
in the regex in <code>names_pattern</code>, we have two pairings --&gt;
<code>{".value":["n", "pct"], "name":[1,2,3]}</code>. Just like in the previous
example, the values associated with <code>.value</code> become new column names,
while those not associated with <code>.value</code> become values in the new column
<code>name</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are no limits to the pairing; however, you can only have
one <code>.value</code> in <code>names_to</code>.</p>
</div>
<p>Example 5: You can also pass a list/tuple of regular expressions that match
specific patterns to <code>names_pattern</code>, along with a list/tuple of new
names to <code>names_to</code>; this can come in handy if <code>.value</code> falls short:</p>
<pre><code class="language-python">      GameID   Date         Visitor      Score_V       Home         Score_H
    0  1     9/10/2020   Houston Texans     20    Kansas City Chiefs   34
    1  2     9/13/2020   Seattle Seahawks   38    Atlanta Falcons      25



    df.pivot_longer(
        index = ['GameID','Date'],
        names_to = (&quot;Team&quot;,&quot;Score&quot;),
        names_pattern = (&quot;^Visitor|Home&quot;, &quot;^Score&quot;)
        )

           GameID       Date              Team       Score
    0       1       9/10/2020      Houston Texans     20
    1       2       9/13/2020    Seattle Seahawks     38
    2       1       9/10/2020  Kansas City Chiefs     34
    3       2       9/13/2020     Atlanta Falcons     25
</code></pre>
<p>Note that in the code above, the number of entries in both <code>names_to</code> and
<code>names_pattern</code> must match. Essentially, what the code does is look for
columns that start with <code>Visitor</code> or <code>Home</code> (using the regex supplied) and
puts all the values associated with these columns under a new column name
<code>Team</code>. It then looks for columns that start with <code>Score</code> and collate all
the values associated with these columns to a single column named <code>Score</code>.</p>
<p>You can also take advantage of <code>janitor.patterns</code> function,
or the <code>select_columns</code> syntax, which allows selection of columns via a
regular expression; this can come in handy if you have a lot of
column names to pass to the <code>index</code> or <code>column_names</code>  parameters,
and you do not wish to manually type them all.</p>
<pre><code class="language-python">         name    wk1   wk2   wk3   wk4
    0    Alice     5     9    20    22
    1    Bob       7    11    17    33
    2    Carla     6    13    39    40

    df.pivot_longer(index = janitor.patterns(&quot;^(?!wk)&quot;))


         name   variable  value
    0   Alice      wk1      5
    1     Bob      wk1      7
    2   Carla      wk1      6
    3   Alice      wk2      9
    4     Bob      wk2     11
    5   Carla      wk2     13
    6   Alice      wk3     20
    7     Bob      wk3     17
    8   Carla      wk3     39
    9   Alice      wk4     22
    10    Bob      wk4     33
    11  Carla      wk4     40
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unpivoting a DataFrame with MultiIndex columns, when
either <code>names_sep</code> or <code>names_pattern</code> is provided is not
supported.</p>
</div>
<p>Functional usage syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor as jn

df = pd.DataFrame(...)
df = jn.pivot_longer(
    df = df,
    index = [column1, column2, ...],
    column_names = [column3, column4, ...],
    names_to = new_column_name,
    names_sep = string/regular expression,
    names_pattern = string/regular expression,
    values_to= new_column_name,
    column_level = None/int/str,
    sort_by_appearance = True/False,
    ignore_index = True/False,
)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">df = (
    pd.DataFrame(...)
    .pivot_longer(
        index = [column1, column2, ...],
        column_names = [column3, column4, ...],
        names_to = new_column_name,
        names_sep = string/regular expression,
        names_pattern = string/regular expression,
        values_to = new_column_name,
        column_level = None/int/str,
        sort_by_appearance = True/False,
        ignore_index = True/False,
    )
)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>index</code></td>
        <td><code>Union[List, Tuple, str, Pattern]</code></td>
        <td><p>Name(s) of columns to use as identifier variables. Should be either a single column name, or a list/tuple of column names. The <code>janitor.select_columns</code> syntax is supported here, allowing for flexible and dynamic column selection. Index should be a list of tuples if the columns are a MultiIndex.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[List, Tuple, str, Pattern]</code></td>
        <td><p>Name(s) of columns to unpivot. Should be either a single column name or a list/tuple of column names. The <code>janitor.select_columns</code> syntax is supported here, allowing for flexible and dynamic column selection. Column_names should be a list of tuples if the columns are a MultiIndex.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>names_to</code></td>
        <td><code>Union[List, Tuple, str]</code></td>
        <td><p>Name of new column as a string that will contain what were previously the column names in <code>column_names</code>. The default is <code>variable</code> if no value is provided. It can also be a list/tuple of strings that will serve as new column names, if <code>name_sep</code> or <code>names_pattern</code> is provided. If <code>.value</code> is in <code>names_to</code>, new column names will be extracted from part of the existing column names and overrides<code>values_to</code>.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>names_sep</code></td>
        <td><code>Union[str, Pattern]</code></td>
        <td><p>Determines how the column name is broken up, if <code>names_to</code> contains multiple values. It takes the same specification as pandas' <code>str.split</code> method, and can be a string or regular expression. <code>names_sep</code> does not work with MultiIndex columns.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>names_pattern</code></td>
        <td><code>Union[List, Tuple, str, Pattern]</code></td>
        <td><p>Determines how the column name is broken up. It can be a regular expression containing matching groups (it takes the same specification as pandas' <code>str.extract</code> method), or a list/tuple of regular expressions. If it is a single regex, the number of groups must match the length of <code>names_to</code> ( if the length of <code>names_to</code> is 3, then the number of groups must be 3. If <code>names_to</code> is a string, then there should be only one group in <code>names_pattern``). For a list/tuple of regular expressions,</code>names_to<code>must also be a list/tuple and the lengths of both arguments must match(if the length of</code>names_to<code>is 4, then the length of</code>names_pattern<code>must also be 4). The entries in both arguments must also match positionally, i.e  if</code>names_to = ("name1", "name2", "name3")<code>, then `names_pattern</code> should be ("regex1", "regex2", "regex3"), with "name1" pairing "regex1", "name2" pairing "regex2", and "name3" pairing "regex3". <code>names_pattern</code> does not work with MultiIndex columns.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>values_to</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>Name of new column as a string that will contain what were previously the values of the columns in <code>column_names</code>.</p></td>
        <td><code>&#39;value&#39;</code></td>
      </tr>
      <tr>
        <td><code>column_level</code></td>
        <td><code>Union[int, str]</code></td>
        <td><p>If columns are a MultiIndex, then use this level to unpivot the DataFrame. Provided for compatibility with pandas' melt, and applies only if neither <code>names_sep</code> nor <code>names_pattern</code> is provided.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>sort_by_appearance</code></td>
        <td><code>Optional[bool]</code></td>
        <td><p>Default <code>False</code>. Boolean value that determines the final look of the DataFrame. If <code>True</code>, the unpivoted DataFrame will be stacked in order of first appearance. See examples for more details. <code>pivot_longer</code> is usually more performant if <code>sort_by_appearance</code> is `False``.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>ignore_index</code></td>
        <td><code>Optional[bool]</code></td>
        <td><p>Default <code>True</code>. If True, original index is ignored. If False, the original index is retained and the Index labels will be repeated as necessary.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame that has been unpivoted from wide to long format.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/pivot.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def pivot_longer(
    df: pd.DataFrame,
    index: Optional[Union[List, Tuple, str, Pattern]] = None,
    column_names: Optional[Union[List, Tuple, str, Pattern]] = None,
    names_to: Optional[Union[List, Tuple, str]] = None,
    values_to: Optional[str] = "value",
    column_level: Optional[Union[int, str]] = None,
    names_sep: Optional[Union[str, Pattern]] = None,
    names_pattern: Optional[Union[List, Tuple, str, Pattern]] = None,
    sort_by_appearance: Optional[bool] = False,
    ignore_index: Optional[bool] = True,
) -&gt; pd.DataFrame:
    """
    Unpivots a DataFrame from *wide* to *long* format.

    This method does not mutate the original DataFrame.

    It is a wrapper around `pd.melt` and is meant to serve as a single point
    for transformations that require `pd.melt` or `pd.wide_to_long`.

    It is modeled after the `pivot_longer` function in R's tidyr package, and
    offers more functionality and flexibility than `pd.wide_to_long`.

    This function is useful to massage a DataFrame into a format where
    one or more columns are considered measured variables, and all other
    columns are considered as identifier variables.

    All measured variables are *unpivoted* (and typically duplicated) along the
    row axis.


    Example 1: The following DataFrame contains heartrate data for patients
    treated with two different drugs, `a` and `b`.

    ```python
              name   a   b
        0   Wilbur  67  56
        1  Petunia  80  90
        2  Gregory  64  50
    ```

    The column names `a` and `b` are actually the names of a measured variable
    (i.e. the name of a drug), but the values are a different measured variable
    (heartrate). We would like to unpivot these `a` and `b` columns into a
    `drug` column and a `heartrate` column.

    ```python
        df.pivot_longer(
            column_names = ['a', 'b'],
            names_to = 'drug',
            values_to = 'heartrate',
            sort_by_appearance = True
        )


              name drug  heartrate
        0   Wilbur    a         67
        1   Wilbur    b         56
        2  Petunia    a         80
        3  Petunia    b         90
        4  Gregory    a         64
        5  Gregory    b         50
    ```

    Note how the data is stacked in order of first appearance. If, however,
    you do not care for order of appearance, and want to wring out some
    more performance, you can set `sort_by_appearance` to `False` (the
    default is `False`).

    ```python
        df.pivot_longer(
            column_names = ['a', 'b'],
            names_to = 'drug',
            values_to = 'heartrate',
            sort_by_appearance = False
        )


                name     drug  heartrate
        0	Wilbur	   a	67
        1	Petunia	   a	80
        2	Gregory    a	64
        3	Wilbur	   b	56
        4	Petunia	   b	90
        5	Gregory	   b	50
    ```

    You can set `ignore_index` to `False`, if you wish to reuse the index
    from the source DataFrame (the index will be repeated as many times as
    necessary):


    ```python
        df.pivot_longer(
            column_names = ['a', 'b'],
            names_to = 'drug',
            values_to = 'heartrate',
            sort_by_appearance = False,
            ignore_index = False
        )


                name     drug  heartrate
        0	Wilbur	   a	67
        1	Petunia	   a	80
        2	Gregory    a	64
        0	Wilbur	   b	56
        1	Petunia	   b	90
        2	Gregory	   b	50
    ```

    MultiIndex DataFrames are unpivoted in the same form that you would
    expect from pandas' `melt`:

    ```python
            A  B  C
            D  E  F
        0   a  1  2
        1   b  3  4
        2   c  5  6

        df.pivot_longer(
            index = [("A", "D")],
            names_to = ["first", "second"]
        )


             (A, D)  first   second   value
        0	a	B	E	1
        1	b	B	E	3
        2	c	B	E	5
        3	a	C	F	2
        4	b	C	F	4
        5	c	C	F	6
    ```

    You can also unpivot on a specific level:


    ```python
        df.pivot_longer(
            index = "A",
            names_to = "first",
            column_level = 0
        )


           A      first  value
        0  a        B      1
        1  b        B      3
        2  c        B      5
    ```

    Example 2: The DataFrame below has year and month variables embedded within
    the column names.


    ```python
              col1	    2019-12	 2020-01	 2020-02
        0	a	   -1.085631	-1.506295	-2.426679
        1	b	    0.997345	-0.578600	-0.428913
        2	c	    0.282978	 1.651437	 1.265936
    ```

    `pivot_longer` can conveniently reshape the DataFrame into long format,
    with new columns for the year and month. You simply pass in the new
    column names to `names_to`, and pass the hyphen `-` to the `names_sep`
    argument.


    ```python
        df.pivot_longer(
            index = 'col1',
            names_to = ('year', 'month'),
            names_sep = '-',
            sort_by_appearance = True
        )

           col1 year   month      value
        0    a  2019     12     -1.085631
        1    a  2020     01     -1.506295
        2    a  2020     02     -2.426679
        3    b  2019     12      0.997345
        4    b  2020     01     -0.578600
        5    b  2020     02     -0.428913
        6    c  2019     12      0.282978
        7    c  2020     01      1.651437
        8    c  2020     02      1.265936
    ```

    Example 3: The DataFrame below has names embedded in it
    `(measure1, measure2)` that we would love to reuse as column names.


    ```python
            treat1-measure1     treat1-measure2 treat2-measure1 treat2-measure2
        0                1              4                   2               5
        1                2              5                   3               4
    ```

    For this, we use the `.value` variable, which signals to `pivot_longer`
    to treat the part of the column names corresponding to `.value` as new
    column names. The `.value` variable is similar to `stubnames` in pandas'
    `wide_to_long` function, but with more flexibility.


    ```python
        df.pivot_longer(
            names_to = ("group", '.value'),
            names_sep = '-',
            sort_by_appearance = True
        )


            group  measure1  measure2
        0  treat1         1         4
        1  treat2         2         5
        2  treat1         2         5
        3  treat2         3         4
    ```

    Let's break down the `.value` idea. When `.value` is used, `pivot_longer`
    creates a pairing. In the example above, we get a pairing
    `{"group":["treat1", "treat2"], ".value":["measure1", "measure2"]}`. All
    the values associated with `.value` become new column names, while those
    not associated with `.value`(`treat1` and `treat2`) become values in a
    new column `group`. `values_to` is overridden during this process.

    !!! note
        The values not associated with `.value` (in the example above,
        this is the `group` column) are returned as object dtypes. You can
        change it to your preferred dtype using pandas' `astype` method.

    Example 4: You can also unpivot from wide to long using regular expressions


    ```python
            n_1  n_2  n_3  pct_1  pct_2  pct_3
        0   10   20   30   0.1    0.2    0.3

        df.pivot_longer(
            names_to = (".value", "name"),
            names_pattern = "(.*)_(.)"
         )


            name    n  pct
        0     1  10.0  0.1
        1     2  20.0  0.2
        2     3  30.0  0.3
    ```

    The same idea of `.value` works here as well. Based on the capturing groups
    in the regex in `names_pattern`, we have two pairings --&gt;
    `{".value":["n", "pct"], "name":[1,2,3]}`. Just like in the previous
    example, the values associated with `.value` become new column names,
    while those not associated with `.value` become values in the new column
    `name`.

    !!!note
        There are no limits to the pairing; however, you can only have
        one `.value` in `names_to`.

    Example 5: You can also pass a list/tuple of regular expressions that match
    specific patterns to `names_pattern`, along with a list/tuple of new
    names to `names_to`; this can come in handy if `.value` falls short:

    ```python
          GameID   Date	        Visitor	     Score_V	   Home	        Score_H
        0  1     9/10/2020   Houston Texans     20    Kansas City Chiefs   34
        1  2     9/13/2020   Seattle Seahawks   38    Atlanta Falcons      25



        df.pivot_longer(
            index = ['GameID','Date'],
            names_to = ("Team","Score"),
            names_pattern = ("^Visitor|Home", "^Score")
            )

               GameID       Date              Team       Score
        0       1       9/10/2020      Houston Texans     20
        1       2       9/13/2020    Seattle Seahawks     38
        2       1       9/10/2020  Kansas City Chiefs     34
        3       2       9/13/2020     Atlanta Falcons     25
    ```

    Note that in the code above, the number of entries in both `names_to` and
    `names_pattern` must match. Essentially, what the code does is look for
    columns that start with `Visitor` or `Home` (using the regex supplied) and
    puts all the values associated with these columns under a new column name
    `Team`. It then looks for columns that start with `Score` and collate all
    the values associated with these columns to a single column named `Score`.

    You can also take advantage of `janitor.patterns` function,
    or the `select_columns` syntax, which allows selection of columns via a
    regular expression; this can come in handy if you have a lot of
    column names to pass to the `index` or `column_names`  parameters,
    and you do not wish to manually type them all.

    ```python
             name    wk1   wk2   wk3   wk4
        0    Alice     5     9    20    22
        1    Bob       7    11    17    33
        2    Carla     6    13    39    40

        df.pivot_longer(index = janitor.patterns("^(?!wk)"))


             name   variable  value
        0   Alice      wk1      5
        1     Bob      wk1      7
        2   Carla      wk1      6
        3   Alice      wk2      9
        4     Bob      wk2     11
        5   Carla      wk2     13
        6   Alice      wk3     20
        7     Bob      wk3     17
        8   Carla      wk3     39
        9   Alice      wk4     22
        10    Bob      wk4     33
        11  Carla      wk4     40
    ```

    !!!note
        Unpivoting a DataFrame with MultiIndex columns, when
        either `names_sep` or `names_pattern` is provided is not
        supported.


    Functional usage syntax:

    ```python
    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)
    df = jn.pivot_longer(
        df = df,
        index = [column1, column2, ...],
        column_names = [column3, column4, ...],
        names_to = new_column_name,
        names_sep = string/regular expression,
        names_pattern = string/regular expression,
        values_to= new_column_name,
        column_level = None/int/str,
        sort_by_appearance = True/False,
        ignore_index = True/False,
    )
    ```

    Method chaining syntax:

    ```python
    df = (
        pd.DataFrame(...)
        .pivot_longer(
            index = [column1, column2, ...],
            column_names = [column3, column4, ...],
            names_to = new_column_name,
            names_sep = string/regular expression,
            names_pattern = string/regular expression,
            values_to = new_column_name,
            column_level = None/int/str,
            sort_by_appearance = True/False,
            ignore_index = True/False,
        )
    )
    ```

    :param df: A pandas DataFrame.
    :param index: Name(s) of columns to use as identifier variables.
        Should be either a single column name, or a list/tuple of
        column names. The `janitor.select_columns` syntax is supported here,
        allowing for flexible and dynamic column selection.
        Index should be a list of tuples if the columns are a MultiIndex.
    :param column_names: Name(s) of columns to unpivot. Should be either
        a single column name or a list/tuple of column names.
        The `janitor.select_columns` syntax is supported here,
        allowing for flexible and dynamic column selection.
        Column_names should be a list of tuples
        if the columns are a MultiIndex.
    :param names_to: Name of new column as a string that will contain
        what were previously the column names in `column_names`.
        The default is `variable` if no value is provided. It can
        also be a list/tuple of strings that will serve as new column
        names, if `name_sep` or `names_pattern` is provided.
        If `.value` is in `names_to`, new column names will be extracted
        from part of the existing column names and overrides`values_to`.
    :param names_sep: Determines how the column name is broken up, if
        `names_to` contains multiple values. It takes the same
        specification as pandas' `str.split` method, and can be a string
        or regular expression. `names_sep` does not work with MultiIndex
        columns.
    :param names_pattern: Determines how the column name is broken up.
        It can be a regular expression containing matching groups (it takes
        the same specification as pandas' `str.extract` method), or a
        list/tuple of regular expressions. If it is a single regex, the
        number of groups must match the length of `names_to` ( if the
        length of `names_to` is 3, then the number of groups must be 3.
        If `names_to` is a string, then there should be only one group
        in `names_pattern``). For a list/tuple of regular expressions,
        `names_to` must also be a list/tuple and the lengths of both
        arguments must match(if the length of `names_to` is 4, then the
        length of `names_pattern` must also be 4). The entries in both
        arguments must also match positionally, i.e  if
        `names_to = ("name1", "name2", "name3")``, then `names_pattern``
        should be ("regex1", "regex2", "regex3"), with "name1" pairing
        "regex1", "name2" pairing "regex2", and "name3" pairing "regex3".
        `names_pattern` does not work with MultiIndex columns.
    :param values_to: Name of new column as a string that will contain what
        were previously the values of the columns in `column_names`.
    :param column_level: If columns are a MultiIndex, then use this level to
        unpivot the DataFrame. Provided for compatibility with pandas' melt,
        and applies only if neither `names_sep` nor `names_pattern` is
        provided.
    :param sort_by_appearance: Default `False`. Boolean value that determines
        the final look of the DataFrame. If `True`, the unpivoted DataFrame
        will be stacked in order of first appearance. See examples for more
        details. `pivot_longer` is usually more performant if
        `sort_by_appearance` is `False``.
    :param ignore_index: Default `True`. If True, original index is ignored.
        If False, the original index is retained and the Index labels will be
        repeated as necessary.
    :returns: A pandas DataFrame that has been unpivoted from wide to long
        format.
    """

    # this code builds on the wonderful work of @benjaminjack’s PR
    # https://github.com/benjaminjack/pyjanitor/commit/e3df817903c20dd21634461c8a92aec137963ed0

    df = df.copy()

    (
        df,
        index,
        column_names,
        names_to,
        values_to,
        column_level,
        names_sep,
        names_pattern,
        sort_by_appearance,
        ignore_index,
    ) = _data_checks_pivot_longer(
        df,
        index,
        column_names,
        names_to,
        values_to,
        column_level,
        names_sep,
        names_pattern,
        sort_by_appearance,
        ignore_index,
    )

    return _computations_pivot_longer(
        df,
        index,
        column_names,
        names_to,
        values_to,
        column_level,
        names_sep,
        names_pattern,
        sort_by_appearance,
        ignore_index,
    )
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.pivot.pivot_wider" class="doc doc-heading">
<code class="highlight language-python">pivot_wider(df, index=None, names_from=None, values_from=None, levels_order=None, flatten_levels=True, names_sep='_', names_glue=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Reshapes data from 'long' to 'wide' form.</p>
<p>The number of columns are increased, while decreasing
the number of rows. It is the inverse of the <code>pivot_longer</code>
method, and is a wrapper around <code>pd.DataFrame.pivot</code> method.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>.. note:: Column selection in <code>index</code>, <code>names_from</code>
    and <code>values_from</code> is possible using the
    <code>janitor.select_columns</code> syntax.</p>
<p>.. note:: A ValueError is raised if the combination
    of the <code>index</code> and <code>names_from</code> is not unique.</p>
<p>.. note:: By default, values from <code>values_from</code> are always
    at the top level if the columns are not flattened.
    If flattened, the values from <code>values_from</code> are usually
    at the start of each label in the columns.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)

    df = jn.pivot_wider(
        df = df,
        index = [column1, column2, ...],
        names_from = [column3, column4, ...],
        value_from = [column5, column6, ...],
        levels_order = None/list,
        flatten_levels = True/False,
        names_sep='_',
        names_glue= Callable

    )
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    df = (
        pd.DataFrame(...)
        .pivot_wider(
            index = [column1, column2, ...],
            names_from = [column3, column4, ...],
            value_from = [column5, column6, ...],
            levels_order = None/list,
            flatten_levels = True/False,
            names_sep='_',
            names_glue= Callable
            )
    )
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>index</code></td>
        <td><code>Union[List, str]</code></td>
        <td><p>Name(s) of columns to use as identifier variables. Should be either a single column name, or a list of column names. The <code>janitor.select_columns</code> syntax is supported here, allowing for flexible and dynamic column selection. If <code>index</code> is not provided, the dataframe's index is used.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>names_from</code></td>
        <td><code>Union[List, str]</code></td>
        <td><p>Name(s) of column(s) to use to make the new dataframe's columns. Should be either a single column name, or a list of column names. The <code>janitor.select_columns</code> syntax is supported here, allowing for flexible and dynamic column selection. A label or labels must be provided for <code>names_from</code>.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>values_from</code></td>
        <td><code>Union[List, str]</code></td>
        <td><p>Name(s) of column(s) that will be used for populating the new dataframe's values. The <code>janitor.select_columns</code> syntax is supported here, allowing for flexible and dynamic column selection. If <code>values_from</code> is not specified,  all remaining columns will be used. Note that values from <code>values_from</code> are usually at the top level, the dataframe's columns is not flattened, or the start of each label in the columns, if flattened.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>levels_order</code></td>
        <td><code>Optional[list]</code></td>
        <td><p>Applicable if there are multiple <code>names_from</code> and/or <code>values_from</code>. Reorders the levels. Accepts a list of strings. If there are multiple <code>values_from</code>, pass a None to represent that level.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>flatten_levels</code></td>
        <td><code>Optional[bool]</code></td>
        <td><p>Default is <code>True</code>. If <code>False</code>, the dataframe stays as a MultiIndex.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>names_sep</code></td>
        <td></td>
        <td><p>If <code>names_from</code> or <code>values_from</code> contain multiple variables, this will be used to join their values into a single string to use as a column name. Default is <code>_</code>. Applicable only if <code>flatten_levels</code> is <code>True</code>.</p></td>
        <td><code>&#39;_&#39;</code></td>
      </tr>
      <tr>
        <td><code>names_glue</code></td>
        <td><code>Callable</code></td>
        <td><p>A callable to control the output of the flattened columns. Applicable only if <code>flatten_levels</code> is True. Function should be acceptable to pandas’ <code>map</code> function.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame that has been unpivoted from long to wide form.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/pivot.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def pivot_wider(
    df: pd.DataFrame,
    index: Optional[Union[List, str]] = None,
    names_from: Optional[Union[List, str]] = None,
    values_from: Optional[Union[List, str]] = None,
    levels_order: Optional[list] = None,
    flatten_levels: Optional[bool] = True,
    names_sep="_",
    names_glue: Callable = None,
) -&gt; pd.DataFrame:
    """
    Reshapes data from 'long' to 'wide' form.

    The number of columns are increased, while decreasing
    the number of rows. It is the inverse of the `pivot_longer`
    method, and is a wrapper around `pd.DataFrame.pivot` method.

    This method does not mutate the original DataFrame.

    .. note:: Column selection in `index`, `names_from`
        and `values_from` is possible using the
        `janitor.select_columns` syntax.

    .. note:: A ValueError is raised if the combination
        of the `index` and `names_from` is not unique.

    .. note:: By default, values from `values_from` are always
        at the top level if the columns are not flattened.
        If flattened, the values from `values_from` are usually
        at the start of each label in the columns.

    Functional usage syntax:

    ```python
        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)

        df = jn.pivot_wider(
            df = df,
            index = [column1, column2, ...],
            names_from = [column3, column4, ...],
            value_from = [column5, column6, ...],
            levels_order = None/list,
            flatten_levels = True/False,
            names_sep='_',
            names_glue= Callable

        )
    ```

    Method chaining syntax:

    ```python
        df = (
            pd.DataFrame(...)
            .pivot_wider(
                index = [column1, column2, ...],
                names_from = [column3, column4, ...],
                value_from = [column5, column6, ...],
                levels_order = None/list,
                flatten_levels = True/False,
                names_sep='_',
                names_glue= Callable
                )
        )
    ```

    :param df: A pandas dataframe.
    :param index: Name(s) of columns to use as identifier variables.
        Should be either a single column name, or a list of column names.
        The `janitor.select_columns` syntax is supported here,
        allowing for flexible and dynamic column selection.
        If `index` is not provided, the dataframe's index is used.
    :param names_from: Name(s) of column(s) to use to make the new
        dataframe's columns. Should be either a single column name, or a
        list of column names.
        The `janitor.select_columns` syntax is supported here,
        allowing for flexible and dynamic column selection.
        A label or labels must be provided for `names_from`.
    :param values_from: Name(s) of column(s) that will be used for populating
        the new dataframe's values.
        The `janitor.select_columns` syntax is supported here,
        allowing for flexible and dynamic column selection.
        If ``values_from`` is not specified,  all remaining columns
        will be used. Note that values from `values_from` are usually at
        the top level, the dataframe's columns is not flattened, or the
        start of each label in the columns, if flattened.
    :param levels_order: Applicable if there are multiple `names_from`
        and/or `values_from`. Reorders the levels. Accepts a list of strings.
        If there are multiple `values_from`, pass a None to represent that
        level.
    :param flatten_levels: Default is `True`. If `False`, the dataframe stays
        as a MultiIndex.
    :param names_sep: If `names_from` or `values_from` contain multiple
        variables, this will be used to join their values into a single string
        to use as a column name. Default is `_`.
        Applicable only if `flatten_levels` is `True`.
    :param names_glue: A callable to control
        the output of the flattened columns.
        Applicable only if `flatten_levels` is True.
        Function should be acceptable to pandas’ `map` function.
    :returns: A pandas DataFrame that has been unpivoted from long to wide
        form.
    """

    df = df.copy()

    return _computations_pivot_wider(
        df,
        index,
        names_from,
        values_from,
        levels_order,
        flatten_levels,
        names_sep,
        names_glue,
    )
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.process_text" class="doc doc-heading">
        <code>process_text</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.process_text.process_text" class="doc doc-heading">
<code class="highlight language-python">process_text(df, column_name, string_function, **kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Apply a Pandas string method to an existing column and return a dataframe.</p>
<p>This function aims to make string cleaning easy, while chaining,
by simply passing the string method name to the <code>process_text</code> function.
This modifies an existing column; it does not create a new column.
New columns can be created via pyjanitor's <code>transform_columns</code>.</p>
<p>A list of all the string methods in Pandas can be accessed <code>here
&lt;https://pandas.pydata.org/docs/user_guide/text.html#method-summary&gt;</code>__.</p>
<p>Example:</p>
<pre class="highlight"><code>import pandas as pd
import janitor as jn

         text  code
0      Ragnar     1
1  sammywemmy     2
2      ginger     3

df.process_text(column_name = "text",
                string_function = "lower")

  text          code
0 ragnar         1
1 sammywemmy     2
2 ginger         3
</code></pre>
<p>For string methods with parameters, simply pass the keyword arguments::</p>
<pre class="highlight"><code>df.process_text(
    column_name = "text",
    string_function = "extract",
    pat = r"(ag)",
    expand = False,
    flags = re.IGNORECASE
    )

  text     code
0 ag        1
1 NaN       2
2 NaN       3
</code></pre>
<p>Functional usage syntax:</p>
<pre class="highlight"><code>import pandas as pd
import janitor as jn

df = pd.DataFrame(...)
df = jn.process_text(
    df = df,
    column_name,
    string_function = "string_func_name_here",
    kwargs
    )
</code></pre>
<p>Method-chaining usage syntax:</p>
<pre class="highlight"><code>import pandas as pd
import janitor as jn

df = (
    pd.DataFrame(...)
    .process_text(
        column_name,
        string_function = "string_func_name_here",
        kwargs
        )
)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>str</code></td>
        <td><p>String column to be operated on.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>string_function</code></td>
        <td><code>str</code></td>
        <td><p>Pandas string method to be applied.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td><code>str</code></td>
        <td><p>Keyword arguments for parameters of the <code>string_function</code>.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas dataframe with modified column(s).</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>KeyError</code></td>
        <td><p>if <code>string_function</code> is not a Pandas string method.</p></td>
      </tr>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>if the wrong <code>kwarg</code> is supplied.</p></td>
      </tr>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>column_name</code> not found in dataframe.  .. # noqa: DAR402</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/process_text.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def process_text(
    df: pd.DataFrame,
    column_name: str,
    string_function: str,
    **kwargs: str,
) -&gt; pd.DataFrame:
    """
    Apply a Pandas string method to an existing column and return a dataframe.

    This function aims to make string cleaning easy, while chaining,
    by simply passing the string method name to the ``process_text`` function.
    This modifies an existing column; it does not create a new column.
    New columns can be created via pyjanitor's `transform_columns`.


    A list of all the string methods in Pandas can be accessed `here
    &lt;https://pandas.pydata.org/docs/user_guide/text.html#method-summary&gt;`__.

    Example:



        import pandas as pd
        import janitor as jn

                 text  code
        0      Ragnar     1
        1  sammywemmy     2
        2      ginger     3

        df.process_text(column_name = "text",
                        string_function = "lower")

          text          code
        0 ragnar         1
        1 sammywemmy     2
        2 ginger         3

    For string methods with parameters, simply pass the keyword arguments::

        df.process_text(
            column_name = "text",
            string_function = "extract",
            pat = r"(ag)",
            expand = False,
            flags = re.IGNORECASE
            )

          text     code
        0 ag        1
        1 NaN       2
        2 NaN       3

    Functional usage syntax:



        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)
        df = jn.process_text(
            df = df,
            column_name,
            string_function = "string_func_name_here",
            kwargs
            )

    Method-chaining usage syntax:



        import pandas as pd
        import janitor as jn

        df = (
            pd.DataFrame(...)
            .process_text(
                column_name,
                string_function = "string_func_name_here",
                kwargs
                )
        )


    :param df: A pandas dataframe.
    :param column_name: String column to be operated on.
    :param string_function: Pandas string method to be applied.
    :param kwargs: Keyword arguments for parameters of the `string_function`.
    :returns: A pandas dataframe with modified column(s).
    :raises KeyError: if ``string_function`` is not a Pandas string method.
    :raises TypeError: if the wrong ``kwarg`` is supplied.
    :raises ValueError: if `column_name` not found in dataframe.

    .. # noqa: DAR402
    """
    check("column_name", column_name, [str])
    check("string_function", string_function, [str])
    check_column(df, [column_name])

    pandas_string_methods = [
        func.__name__
        for _, func in inspect.getmembers(pd.Series.str, inspect.isfunction)
        if not func.__name__.startswith("_")
    ]

    if string_function not in pandas_string_methods:
        raise KeyError(f"{string_function} is not a Pandas string method.")

    result = getattr(df[column_name].str, string_function)(**kwargs)

    if isinstance(result, pd.DataFrame):
        raise ValueError(
            """
            The outcome of the processed text is a DataFrame,
            which is not supported in `process_text`.
            """
        )

    return df.assign(**{column_name: result})
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.remove_columns" class="doc doc-heading">
        <code>remove_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.remove_columns.remove_columns" class="doc doc-heading">
<code class="highlight language-python">remove_columns(df, column_names)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Remove the set of columns specified in <code>column_names</code>.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Intended to be the method-chaining alternative to <code>del df[col]</code>.</p>
<p>Method chaining syntax:</p>
<pre class="highlight"><code>df = pd.DataFrame(...).remove_columns(column_names=['col1', 'col2'])


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[str, Iterable[str], Hashable]</code></td>
        <td><p>The columns to remove.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/remove_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names")
def remove_columns(
    df: pd.DataFrame, column_names: Union[str, Iterable[str], Hashable]
) -&gt; pd.DataFrame:
    """Remove the set of columns specified in `column_names`.

    This method does not mutate the original DataFrame.

    Intended to be the method-chaining alternative to `del df[col]`.

    Method chaining syntax:

        df = pd.DataFrame(...).remove_columns(column_names=['col1', 'col2'])

    :param df: A pandas DataFrame
    :param column_names: The columns to remove.
    :returns: A pandas DataFrame.
    """
    return df.drop(columns=column_names)
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.remove_empty" class="doc doc-heading">
        <code>remove_empty</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.remove_empty.remove_empty" class="doc doc-heading">
<code class="highlight language-python">remove_empty(df)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Drop all rows and columns that are completely null.</p>
<p>This method also resets the index(by default) since it doesn't make sense
to preserve the index of a completely empty row.</p>
<p>This method mutates the original DataFrame.</p>
<p>Implementation is inspired from <a href="https://stackoverflow.com/questions/38884538/python-pandas-find-all-rows-where-all-values-are-nan">StackOverflow</a>.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = remove_empty(df)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
df = pd.DataFrame(...).remove_empty()
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/remove_empty.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def remove_empty(df: pd.DataFrame) -&gt; pd.DataFrame:
    """Drop all rows and columns that are completely null.

    This method also resets the index(by default) since it doesn't make sense
    to preserve the index of a completely empty row.

    This method mutates the original DataFrame.

    Implementation is inspired from [StackOverflow][so].

    [so]: https://stackoverflow.com/questions/38884538/python-pandas-find-all-rows-where-all-values-are-nan

    Functional usage syntax:

    ```python
    df = remove_empty(df)
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    df = pd.DataFrame(...).remove_empty()
    ```

    :param df: The pandas DataFrame object.
    :returns: A pandas DataFrame.
    """  # noqa: E501
    nanrows = df.index[df.isna().all(axis=1)]
    df = df.drop(index=nanrows).reset_index(drop=True)

    nancols = df.columns[df.isna().all(axis=0)]
    df = df.drop(columns=nancols)

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.rename_columns" class="doc doc-heading">
        <code>rename_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.rename_columns.rename_column" class="doc doc-heading">
<code class="highlight language-python">rename_column(df, old_column_name, new_column_name)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Rename a column in place.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = rename_column(df, &quot;old_column_name&quot;, &quot;new_column_name&quot;)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
df = (
    pd.DataFrame(...)
    .rename_column(&quot;old_column_name&quot;, &quot;new_column_name&quot;)
)
</code></pre>
<p>This is just syntactic sugar/a convenience function
for renaming one column at a time.
If you are convinced that there are multiple columns in need of changing,
then use the <code>pandas.DataFrame.rename</code> method.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>old_column_name</code></td>
        <td><code>str</code></td>
        <td><p>The old column name.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>new_column_name</code></td>
        <td><code>str</code></td>
        <td><p>The new column name.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with renamed columns.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/rename_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(old="old_column_name", new="new_column_name")
def rename_column(
    df: pd.DataFrame, old_column_name: str, new_column_name: str
) -&gt; pd.DataFrame:
    """Rename a column in place.

    This method does not mutate the original DataFrame.

    Functional usage syntax:

    ```python
    df = rename_column(df, "old_column_name", "new_column_name")
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    df = (
        pd.DataFrame(...)
        .rename_column("old_column_name", "new_column_name")
    )
    ```

    This is just syntactic sugar/a convenience function
    for renaming one column at a time.
    If you are convinced that there are multiple columns in need of changing,
    then use the `pandas.DataFrame.rename` method.

    :param df: The pandas DataFrame object.
    :param old_column_name: The old column name.
    :param new_column_name: The new column name.
    :returns: A pandas DataFrame with renamed columns.
    """  # noqa: E501
    check_column(df, [old_column_name])

    return df.rename(columns={old_column_name: new_column_name})
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.rename_columns.rename_columns" class="doc doc-heading">
<code class="highlight language-python">rename_columns(df, new_column_names=None, function=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Rename columns.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">df = rename_columns(df, {&quot;old_column_name&quot;: &quot;new_column_name&quot;})
df = rename_columns(df, function = str.upper)
df = rename_columns(
    df,
    function = lambda x : x.lower() if x.startswith(&quot;double&quot;) else x
)
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
df = pd.DataFrame(...).rename_columns({&quot;old_column_name&quot;: &quot;new_column_name&quot;})
</code></pre>
<p>This is just syntactic sugar/a convenience function
for renaming multiple columns at a time.
If you need to rename single column, then use the <code>rename_column</code> method.</p>
<p>One of the new_column_names or function are a required parameter.
If both are provided then new_column_names takes priority and function
is never executed.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>new_column_names</code></td>
        <td><code>Optional[Dict]</code></td>
        <td><p>A dictionary of old and new column names.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>function</code></td>
        <td><code>Callable</code></td>
        <td><p>A function which should be applied to all the columns</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with renamed columns.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if both new_column_names and function are None</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/rename_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def rename_columns(
    df: pd.DataFrame,
    new_column_names: Union[Dict, None] = None,
    function: Callable = None,
) -&gt; pd.DataFrame:
    """Rename columns.

    Functional usage syntax:

    ```python
    df = rename_columns(df, {"old_column_name": "new_column_name"})
    df = rename_columns(df, function = str.upper)
    df = rename_columns(
        df,
        function = lambda x : x.lower() if x.startswith("double") else x
    )
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    df = pd.DataFrame(...).rename_columns({"old_column_name": "new_column_name"})
    ```

    This is just syntactic sugar/a convenience function
    for renaming multiple columns at a time.
    If you need to rename single column, then use the `rename_column` method.

    One of the new_column_names or function are a required parameter.
    If both are provided then new_column_names takes priority and function
    is never executed.

    :param df: The pandas DataFrame object.
    :param new_column_names: A dictionary of old and new column names.
    :param function: A function which should be applied to all the columns
    :returns: A pandas DataFrame with renamed columns.
    :raises ValueError: if both new_column_names and function are None
    """  # noqa: E501

    if new_column_names is None and function is None:
        raise ValueError(
            "One of new_column_names or function must be provided"
        )

    if new_column_names is not None:
        check_column(df, new_column_names)
        return df.rename(columns=new_column_names)

    return df.rename(mapper=function, axis="columns")
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.reorder_columns" class="doc doc-heading">
        <code>reorder_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.reorder_columns.reorder_columns" class="doc doc-heading">
<code class="highlight language-python">reorder_columns(df, column_order)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Reorder DataFrame columns by specifying desired order as list of col names.</p>
<p>Columns not specified retain their order and follow after specified cols.</p>
<p>Validates column_order to ensure columns are all present in DataFrame.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Functional usage syntax:</p>
<p>Given <code>DataFrame</code> with column names <code>col1</code>, <code>col2</code>, <code>col3</code>:</p>
<pre><code class="language-python">df = reorder_columns(df, ['col2', 'col3'])
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">import pandas as pd
import janitor
df = pd.DataFrame(...).reorder_columns(['col2', 'col3'])
</code></pre>
<p>The column order of <code>df</code> is now <code>col2</code>, <code>col3</code>, <code>col1</code>.</p>
<p>Internally, this function uses <code>DataFrame.reindex</code> with <code>copy=False</code>
to avoid unnecessary data duplication.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p><code>DataFrame</code> to reorder</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_order</code></td>
        <td><code>Union[Iterable[str], pandas.core.indexes.base.Index, Hashable]</code></td>
        <td><p>A list of column names or Pandas <code>Index</code> specifying their order in the returned <code>DataFrame</code>.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with reordered columns.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>IndexError</code></td>
        <td><p>if a column within <code>column_order</code> is not found within the DataFrame.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/reorder_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def reorder_columns(
    df: pd.DataFrame, column_order: Union[Iterable[str], pd.Index, Hashable]
) -&gt; pd.DataFrame:
    """Reorder DataFrame columns by specifying desired order as list of col names.

    Columns not specified retain their order and follow after specified cols.

    Validates column_order to ensure columns are all present in DataFrame.

    This method does not mutate the original DataFrame.

    Functional usage syntax:

    Given `DataFrame` with column names `col1`, `col2`, `col3`:

    ```python
    df = reorder_columns(df, ['col2', 'col3'])
    ```

    Method chaining syntax:

    ```python
    import pandas as pd
    import janitor
    df = pd.DataFrame(...).reorder_columns(['col2', 'col3'])
    ```

    The column order of `df` is now `col2`, `col3`, `col1`.

    Internally, this function uses `DataFrame.reindex` with `copy=False`
    to avoid unnecessary data duplication.

    :param df: `DataFrame` to reorder
    :param column_order: A list of column names or Pandas `Index`
        specifying their order in the returned `DataFrame`.
    :returns: A pandas DataFrame with reordered columns.
    :raises IndexError: if a column within `column_order` is not found
        within the DataFrame.
    """
    check("column_order", column_order, [list, tuple, pd.Index])

    if any(col not in df.columns for col in column_order):
        raise IndexError(
            "A column in `column_order` was not found in the DataFrame."
        )

    # if column_order is a Pandas index, needs conversion to list:
    column_order = list(column_order)

    return df.reindex(
        columns=(
            column_order
            + [col for col in df.columns if col not in column_order]
        ),
        copy=False,
    )
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.round_to_fraction" class="doc doc-heading">
        <code>round_to_fraction</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.round_to_fraction.round_to_fraction" class="doc doc-heading">
<code class="highlight language-python">round_to_fraction(df, column_name=None, denominator=None, digits=inf)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Round all values in a column to a fraction.</p>
<p>This method mutates the original DataFrame.</p>
<p>Taken from <a href="https://github.com/sfirke/janitor/issues/235">the R package</a>.</p>
<p>Also, optionally round to a specified number of digits.</p>
<p>Method-chaining usage:</p>
<pre><code class="language-python"># Round to two decimal places
df = pd.DataFrame(...).round_to_fraction('a', 2)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Name of column to round to fraction.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>denominator</code></td>
        <td><code>float</code></td>
        <td><p>The denominator of the fraction for rounding</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>digits</code></td>
        <td><code>float</code></td>
        <td><p>The number of digits for rounding after rounding to the fraction. Default is np.inf (i.e. no subsequent rounding)</p></td>
        <td><code>inf</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with a column's values rounded.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/round_to_fraction.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(col_name="column_name")
def round_to_fraction(
    df: pd.DataFrame,
    column_name: Hashable = None,
    denominator: float = None,
    digits: float = np.inf,
) -&gt; pd.DataFrame:
    """
    Round all values in a column to a fraction.

    This method mutates the original DataFrame.

    Taken from [the R package](https://github.com/sfirke/janitor/issues/235).

    Also, optionally round to a specified number of digits.

    Method-chaining usage:

    ```python
    # Round to two decimal places
    df = pd.DataFrame(...).round_to_fraction('a', 2)
    ```

    :param df: A pandas DataFrame.
    :param column_name: Name of column to round to fraction.
    :param denominator: The denominator of the fraction for rounding
    :param digits: The number of digits for rounding after rounding to the
        fraction. Default is np.inf (i.e. no subsequent rounding)
    :returns: A pandas DataFrame with a column's values rounded.
    """
    if denominator:
        check("denominator", denominator, [float, int])

    if digits:
        check("digits", digits, [float, int])

    df[column_name] = round(df[column_name] * denominator, 0) / denominator
    if not np.isinf(digits):
        df[column_name] = round(df[column_name], digits)

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.row_to_names" class="doc doc-heading">
        <code>row_to_names</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.row_to_names.row_to_names" class="doc doc-heading">
<code class="highlight language-python">row_to_names(df, row_number=None, remove_row=False, remove_rows_above=False, reset_index=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Elevates a row to be the column names of a DataFrame.</p>
<p>This method mutates the original DataFrame.</p>
<p>Contains options to remove the elevated row from the DataFrame along with
removing the rows above the selected row.</p>
<p>Method chaining usage:</p>
<pre class="highlight"><code>df = (
    pd.DataFrame(...)
    .row_to_names(
        row_number=0,
        remove_row=False,
        remove_rows_above=False,
        reset_index=False,
    )
)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>row_number</code></td>
        <td><code>int</code></td>
        <td><p>The row containing the variable names</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>remove_row</code></td>
        <td><code>bool</code></td>
        <td><p>Whether the row should be removed from the DataFrame. Defaults to False.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>remove_rows_above</code></td>
        <td><code>bool</code></td>
        <td><p>Whether the rows above the selected row should be removed from the DataFrame. Defaults to False.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>reset_index</code></td>
        <td><code>bool</code></td>
        <td><p>Whether the index should be reset on the returning DataFrame. Defaults to False.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with set column names.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/row_to_names.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def row_to_names(
    df: pd.DataFrame,
    row_number: int = None,
    remove_row: bool = False,
    remove_rows_above: bool = False,
    reset_index: bool = False,
) -&gt; pd.DataFrame:
    """Elevates a row to be the column names of a DataFrame.

    This method mutates the original DataFrame.

    Contains options to remove the elevated row from the DataFrame along with
    removing the rows above the selected row.

    Method chaining usage:



        df = (
            pd.DataFrame(...)
            .row_to_names(
                row_number=0,
                remove_row=False,
                remove_rows_above=False,
                reset_index=False,
            )
        )

    :param df: A pandas DataFrame.
    :param row_number: The row containing the variable names
    :param remove_row: Whether the row should be removed from the DataFrame.
        Defaults to False.
    :param remove_rows_above: Whether the rows above the selected row should
        be removed from the DataFrame. Defaults to False.
    :param reset_index: Whether the index should be reset on the returning
        DataFrame. Defaults to False.
    :returns: A pandas DataFrame with set column names.
    """
    # :Setup:

    # ```python

    #     import pandas as pd
    #     import janitor
    #     data_dict = {
    #         "a": [1, 2, 3] * 3,
    #         "Bell__Chart": [1, 2, 3] * 3,
    #         "decorated-elephant": [1, 2, 3] * 3,
    #         "animals": ["rabbit", "leopard", "lion"] * 3,
    #         "cities": ["Cambridge", "Shanghai", "Basel"] * 3
    #     }

    # :Example: Move first row to column names:

    # ```python

    #     example_dataframe = pd.DataFrame(data_dict)
    #     example_dataframe.row_to_names(0)

    # :Output:

    # ```python

    #        1  1  1   rabbit  Cambridge
    #     0  1  1  1   rabbit  Cambridge
    #     1  2  2  2  leopard   Shanghai
    #     2  3  3  3     lion      Basel
    #     3  1  1  1   rabbit  Cambridge
    #     4  2  2  2  leopard   Shanghai
    #     5  3  3  3     lion      Basel
    #     6  1  1  1   rabbit  Cambridge
    #     7  2  2  2  leopard   Shanghai

    # :Example: Move first row to column names and
    #  remove row while resetting the index:

    # ```python

    #     example_dataframe = pd.DataFrame(data_dict)
    #     example_dataframe.row_to_names(0, remove_row=True,\
    #       reset_index=True)

    # :Output:

    # ```python

    #       1   1   1   rabbit  Cambridge
    #   0   2   2   2   leopard Shanghai
    #   1   3   3   3   lion    Basel
    #   2   1   1   1   rabbit  Cambridge
    #   3   2   2   2   leopard Shanghai
    #   4   3   3   3   lion    Basel
    #   5   1   1   1   rabbit  Cambridge
    #   6   2   2   2   leopard Shanghai
    #   7   3   3   3   lion    Basel

    # :Example: Move first row to column names and remove
    #   row without resetting the index:

    # ```python

    #     example_dataframe = pd.DataFrame(data_dict)
    #     example_dataframe.row_to_names(0, remove_row=True)

    # :Output:

    # ```python

    #        1  1  1   rabbit  Cambridge
    #     1  2  2  2  leopard   Shanghai
    #     2  3  3  3     lion      Basel
    #     3  1  1  1   rabbit  Cambridge
    #     4  2  2  2  leopard   Shanghai
    #     5  3  3  3     lion      Basel
    #     6  1  1  1   rabbit  Cambridge
    #     7  2  2  2  leopard   Shanghai
    #     8  3  3  3     lion      Basel

    # :Example: Move first row to column names, remove row
    #   and remove rows above selected row without resetting
    #   index:

    # ```python

    #     example_dataframe = pd.DataFrame(data_dict)
    #     example_dataframe.row_to_names(2, remove_row=True, \
    #       remove_rows_above=True, reset_index= True)

    # :Output:

    # ```python

    #       3   3   3   lion    Basel
    #   0   1   1   1   rabbit  Cambridge
    #   1   2   2   2   leopard Shanghai
    #   2   3   3   3   lion    Basel
    #   3   1   1   1   rabbit  Cambridge
    #   4   2   2   2   leopard Shanghai
    #   5   3   3   3   lion    Basel

    # :Example: Move first row to column names, remove row,
    # and remove rows above selected row without resetting
    # index:

    # ```python

    #     example_dataframe = pd.DataFrame(data_dict)
    #     example_dataframe.row_to_names(2, remove_row=True, \
    #       remove_rows_above=True)

    # :Output:

    # ```python

    #        3  3  3     lion      Basel
    #     3  1  1  1   rabbit  Cambridge
    #     4  2  2  2  leopard   Shanghai
    #     5  3  3  3     lion      Basel
    #     6  1  1  1   rabbit  Cambridge
    #     7  2  2  2  leopard   Shanghai
    #     8  3  3  3     lion      Basel

    check("row_number", row_number, [int])

    warnings.warn(
        "The function row_to_names will, in the official 1.0 release, "
        "change its behaviour to reset the dataframe's index by default. "
        "You can prepare for this change right now by explicitly setting "
        "`reset_index=True` when calling on `row_to_names`."
    )

    df.columns = df.iloc[row_number, :]
    df.columns.name = None

    if remove_row:
        df = df.drop(df.index[row_number])

    if remove_rows_above:
        df = df.drop(df.index[range(row_number)])

    if reset_index:
        df = df.reset_index(drop=["index"])

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.select_columns" class="doc doc-heading">
        <code>select_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.select_columns.select_columns" class="doc doc-heading">
<code class="highlight language-python">select_columns(df, *args, *, invert=False)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Method-chainable selection of columns.</p>
<p>Not applicable to MultiIndex columns.</p>
<p>It accepts a string, shell-like glob strings <code>(*string*)</code>,
regex, slice, array-like object, or a list of the previous options.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Optional ability to invert selection of columns available as well.</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    import numpy as np
    import datetime
    import re
    from janitor import patterns
    from pandas.api.types import is_datetime64_dtype

    df = pd.DataFrame(
            {
                &quot;id&quot;: [0, 1],
                &quot;Name&quot;: [&quot;ABC&quot;, &quot;XYZ&quot;],
                &quot;code&quot;: [1, 2],
                &quot;code1&quot;: [4, np.nan],
                &quot;code2&quot;: [&quot;8&quot;, 5],
                &quot;type&quot;: [&quot;S&quot;, &quot;R&quot;],
                &quot;type1&quot;: [&quot;E&quot;, np.nan],
                &quot;type2&quot;: [&quot;T&quot;, &quot;U&quot;],
                &quot;code3&quot;: pd.Series([&quot;a&quot;, &quot;b&quot;], dtype=&quot;category&quot;),
                &quot;type3&quot;: pd.to_datetime([np.datetime64(&quot;2018-01-01&quot;),
                                        datetime.datetime(2018, 1, 1)]),
            }
        )

    df

       id Name  code  code1 code2 type type1 type2 code3    type3
    0   0  ABC     1    4.0     8    S     E     T     a 2018-01-01
    1   1  XYZ     2    NaN     5    R   NaN     U     b 2018-01-01
</code></pre>
<ul>
<li>Select by string:</li>
</ul>
<pre><code>    df.select_columns(&quot;id&quot;)
       id
   0   0
   1   1
</code></pre>
<ul>
<li>Select via shell-like glob strings (<code>*</code>) is possible:</li>
</ul>
<pre><code class="language-python">    df.select_columns(&quot;type*&quot;)

       type type1 type2      type3
    0    S     E     T 2018-01-01
    1    R   NaN     U 2018-01-01
</code></pre>
<ul>
<li>Select by slice:</li>
</ul>
<pre><code class="language-python">    df.select_columns(slice(&quot;code1&quot;, &quot;type1&quot;))

       code1 code2 type type1
    0    4.0     8    S     E
    1    NaN     5    R   NaN
</code></pre>
<ul>
<li>Select by <code>Callable</code> (the callable is applied to every column
  and should return a single <code>True</code> or <code>False</code> per column):</li>
</ul>
<pre><code class="language-python">    df.select_columns(is_datetime64_dtype)

           type3
    0 2018-01-01
    1 2018-01-01

    df.select_columns(lambda x: x.name.startswith(&quot;code&quot;) or
                                x.name.endswith(&quot;1&quot;))

       code  code1 code2 type1 code3
    0     1    4.0     8     E     a
    1     2    NaN     5   NaN     b

    df.select_columns(lambda x: x.isna().any())

         code1 type1
    0    4.0     E
    1    NaN   NaN
</code></pre>
<ul>
<li>Select by regular expression:</li>
</ul>
<pre><code class="language-python">    df.select_columns(re.compile(&quot;\d+&quot;))

       code1 code2 type1 type2 code3      type3
    0    4.0     8     E     T     a 2018-01-01
    1    NaN     5   NaN     U     b 2018-01-01

    # same as above, with janitor.patterns
    # simply a wrapper around re.compile

    df.select_columns(patterns(&quot;\d+&quot;))

       code1 code2 type1 type2 code3      type3
    0    4.0     8     E     T     a 2018-01-01
    1    NaN     5   NaN     U     b 2018-01-01
</code></pre>
<ul>
<li>Select a combination of the above
  (you can combine any of the previous options):</li>
</ul>
<pre><code class="language-python">    df.select_columns(&quot;id&quot;, &quot;code*&quot;, slice(&quot;code&quot;, &quot;code2&quot;))

       id  code  code1 code2 code3
    0   0     1    4.0     8     a
    1   1     2    NaN     5     b
</code></pre>
<ul>
<li>You can also pass a sequence of booleans:</li>
</ul>
<pre><code class="language-python">    df.select_columns([True, False, True, True, True,
                       False, False, False, True, False])

       id  code  code1 code2 code3
    0   0     1    4.0     8     a
    1   1     2    NaN     5     b
</code></pre>
<ul>
<li>Setting <code>invert</code> to <code>True</code>
  returns the complement of the columns provided:</li>
</ul>
<pre><code class="language-python">    df.select_columns(&quot;id&quot;, &quot;code*&quot;, slice(&quot;code&quot;, &quot;code2&quot;),
                      invert = True)

       Name type type1 type2      type3
    0  ABC    S     E     T 2018-01-01
    1  XYZ    R   NaN     U 2018-01-01
</code></pre>
<p>Functional usage example:</p>
<pre><code class="language-python">   import pandas as pd
   import janitor as jn

   df = pd.DataFrame(...)

   df = jn.select_columns('a', 'b', 'col_*',
                          invert=True)
</code></pre>
<p>Method-chaining example:</p>
<pre><code class="language-python">    df = (pd.DataFrame(...)
          .select_columns('a', 'b', 'col_*',
          invert=True))
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>args</code></td>
        <td></td>
        <td><p>Valid inputs include: - an exact column name to look for - a shell-style glob string (e.g., <code>*_thing_*</code>) - a regular expression - a callable which is applicable to each Series in the dataframe - variable arguments of all the aforementioned. - a sequence of booleans.</p></td>
        <td><code>()</code></td>
      </tr>
      <tr>
        <td><code>invert</code></td>
        <td><code>bool</code></td>
        <td><p>Whether or not to invert the selection. This will result in the selection of the complement of the columns provided.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with the specified columns selected.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/select_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(search_cols="search_column_names")
def select_columns(
    df: pd.DataFrame,
    *args,
    invert: bool = False,
) -&gt; pd.DataFrame:
    """
    Method-chainable selection of columns.

    Not applicable to MultiIndex columns.

    It accepts a string, shell-like glob strings `(*string*)`,
    regex, slice, array-like object, or a list of the previous options.

    This method does not mutate the original DataFrame.

    Optional ability to invert selection of columns available as well.

    ```python
        import pandas as pd
        import janitor
        import numpy as np
        import datetime
        import re
        from janitor import patterns
        from pandas.api.types import is_datetime64_dtype

        df = pd.DataFrame(
                {
                    "id": [0, 1],
                    "Name": ["ABC", "XYZ"],
                    "code": [1, 2],
                    "code1": [4, np.nan],
                    "code2": ["8", 5],
                    "type": ["S", "R"],
                    "type1": ["E", np.nan],
                    "type2": ["T", "U"],
                    "code3": pd.Series(["a", "b"], dtype="category"),
                    "type3": pd.to_datetime([np.datetime64("2018-01-01"),
                                            datetime.datetime(2018, 1, 1)]),
                }
            )

        df

           id Name  code  code1 code2 type type1 type2 code3    type3
        0   0  ABC     1    4.0     8    S     E     T     a 2018-01-01
        1   1  XYZ     2    NaN     5    R   NaN     U     b 2018-01-01
    ```

    - Select by string:

    ```
        df.select_columns("id")
           id
       0   0
       1   1
    ```

    - Select via shell-like glob strings (`*`) is possible:

    ```python
        df.select_columns("type*")

           type type1 type2      type3
        0    S     E     T 2018-01-01
        1    R   NaN     U 2018-01-01
    ```

    - Select by slice:

    ```python
        df.select_columns(slice("code1", "type1"))

           code1 code2 type type1
        0    4.0     8    S     E
        1    NaN     5    R   NaN
    ```

    - Select by `Callable` (the callable is applied to every column
      and should return a single `True` or `False` per column):

    ```python
        df.select_columns(is_datetime64_dtype)

               type3
        0 2018-01-01
        1 2018-01-01

        df.select_columns(lambda x: x.name.startswith("code") or
                                    x.name.endswith("1"))

           code  code1 code2 type1 code3
        0     1    4.0     8     E     a
        1     2    NaN     5   NaN     b

        df.select_columns(lambda x: x.isna().any())

             code1 type1
        0    4.0     E
        1    NaN   NaN
    ```

    - Select by regular expression:

    ```python
        df.select_columns(re.compile("\\d+"))

           code1 code2 type1 type2 code3      type3
        0    4.0     8     E     T     a 2018-01-01
        1    NaN     5   NaN     U     b 2018-01-01

        # same as above, with janitor.patterns
        # simply a wrapper around re.compile

        df.select_columns(patterns("\\d+"))

           code1 code2 type1 type2 code3      type3
        0    4.0     8     E     T     a 2018-01-01
        1    NaN     5   NaN     U     b 2018-01-01
    ```

    - Select a combination of the above
      (you can combine any of the previous options):

    ```python
        df.select_columns("id", "code*", slice("code", "code2"))

           id  code  code1 code2 code3
        0   0     1    4.0     8     a
        1   1     2    NaN     5     b
    ```

    - You can also pass a sequence of booleans:

    ```python
        df.select_columns([True, False, True, True, True,
                           False, False, False, True, False])

           id  code  code1 code2 code3
        0   0     1    4.0     8     a
        1   1     2    NaN     5     b
    ```

    - Setting `invert` to `True`
      returns the complement of the columns provided:

    ```python
        df.select_columns("id", "code*", slice("code", "code2"),
                          invert = True)

           Name type type1 type2      type3
        0  ABC    S     E     T 2018-01-01
        1  XYZ    R   NaN     U 2018-01-01
    ```

    Functional usage example:

    ```python
       import pandas as pd
       import janitor as jn

       df = pd.DataFrame(...)

       df = jn.select_columns('a', 'b', 'col_*',
                              invert=True)
    ```

    Method-chaining example:

    ```python
        df = (pd.DataFrame(...)
              .select_columns('a', 'b', 'col_*',
              invert=True))
    ```

    :param df: A pandas DataFrame.
    :param args: Valid inputs include:
        - an exact column name to look for
        - a shell-style glob string (e.g., `*_thing_*`)
        - a regular expression
        - a callable which is applicable to each Series in the dataframe
        - variable arguments of all the aforementioned.
        - a sequence of booleans.
    :param invert: Whether or not to invert the selection.
        This will result in the selection of the complement of the columns
        provided.
    :returns: A pandas DataFrame with the specified columns selected.
    """

    # applicable for any
    # list-like object (ndarray, Series, pd.Index, ...)
    # excluding tuples, which are returned as is
    search_column_names = []
    for arg in args:
        if is_list_like(arg) and (not isinstance(arg, tuple)):
            search_column_names.extend([*arg])
        else:
            search_column_names.append(arg)
    if len(search_column_names) == 1:
        search_column_names = search_column_names[0]

    full_column_list = _select_column_names(search_column_names, df)

    if invert:
        return df.drop(columns=full_column_list)
    return df.loc[:, full_column_list]
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.shuffle" class="doc doc-heading">
        <code>shuffle</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.shuffle.shuffle" class="doc doc-heading">
<code class="highlight language-python">shuffle(df, random_state=None, reset_index=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Shuffle the rows of the DataFrame.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Super-sugary syntax! Underneath the hood, we use <code>df.sample(frac=1)</code>,
with the option to set the random state.</p>
<p>Example usage:</p>
<pre><code class="language-python">    df = pd.DataFrame(...).shuffle()
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>random_state</code></td>
        <td></td>
        <td><p>(optional) A seed for the random number generator.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>reset_index</code></td>
        <td><code>bool</code></td>
        <td><p>(optional) Resets index to default integers</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A shuffled pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/shuffle.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def shuffle(
    df: pd.DataFrame, random_state=None, reset_index: bool = True
) -&gt; pd.DataFrame:
    """Shuffle the rows of the DataFrame.

    This method does not mutate the original DataFrame.

    Super-sugary syntax! Underneath the hood, we use `df.sample(frac=1)`,
    with the option to set the random state.

    Example usage:
    ```python
        df = pd.DataFrame(...).shuffle()
    ```

    :param df: A pandas DataFrame
    :param random_state: (optional) A seed for the random number generator.
    :param reset_index: (optional) Resets index to default integers
    :returns: A shuffled pandas DataFrame.
    """
    result = df.sample(frac=1, random_state=random_state)
    if reset_index:
        result = result.reset_index(drop=True)
    return result
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.sort_column_value_order" class="doc doc-heading">
        <code>sort_column_value_order</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.sort_column_value_order.sort_column_value_order" class="doc doc-heading">
<code class="highlight language-python">sort_column_value_order(df, column, column_value_order, columns=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>This function adds precedence to certain values in a specified column, then
sorts based on that column and any other specified columns.</p>
<p>Example:
                SalesMonth  Company2        Company3
    Company1
    150.0       Jan         180.0       400.0
    200.0       Feb         250.0       500.0
    200.0       Feb         250.0       500.0
    300.0       Mar         NaN             600.0
    400.0       April           500.0           675.0</p>
<pre class="highlight"><code>Given the current DataFrame, we want to order the sales month in desc
order. To achieve this we would assign the later months with smaller
values with the latest month, such as April with the precedence of 0.

df = sort_column_value_order(
df,
'SalesMonth',
{'April':1,'Mar':2,'Feb':3,'Jan':4}
)

The returned DataFrame will look as follows.

            SalesMonth  Company2        Company3
Company1
400.0       April           500.0           675.0
300.0       Mar         NaN             600.0
200.0       Feb         250.0       500.0
200.0       Feb         250.0       500.0
150.0       Jan         180.0       400.0


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>This is our DataFrame that we are manipulating</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column</code></td>
        <td><code>str</code></td>
        <td><p>This is a column name as a string we are using to specify which column to sort by</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_value_order</code></td>
        <td><code>dict</code></td>
        <td><p>This is a dictionary of values that will represent precedence of the values in the specified column</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>columns</code></td>
        <td></td>
        <td><p>This is a list of additional columns that we can sort by</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>This function returns a Pandas DataFrame</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>raises error if chosen Column Name is not in Dataframe, or if column_value_order dictionary is empty.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/sort_column_value_order.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def sort_column_value_order(
    df: pd.DataFrame, column: str, column_value_order: dict, columns=None
) -&gt; pd.DataFrame:
    """
    This function adds precedence to certain values in a specified column, then
    sorts based on that column and any other specified columns.

    Example:
                    SalesMonth	Company2	Company3
        Company1
        150.0	    Jan	        180.0	    400.0
        200.0	    Feb	        250.0	    500.0
        200.0	    Feb	        250.0	    500.0
        300.0	    Mar	        NaN	        600.0
        400.0	    April	    500.0	    675.0

        Given the current DataFrame, we want to order the sales month in desc
        order. To achieve this we would assign the later months with smaller
        values with the latest month, such as April with the precedence of 0.

        df = sort_column_value_order(
        df,
        'SalesMonth',
        {'April':1,'Mar':2,'Feb':3,'Jan':4}
        )

        The returned DataFrame will look as follows.

                    SalesMonth	Company2	Company3
        Company1
        400.0	    April	    500.0	    675.0
        300.0	    Mar	        NaN	        600.0
        200.0	    Feb	        250.0	    500.0
        200.0	    Feb	        250.0	    500.0
        150.0	    Jan	        180.0	    400.0

    :param df: This is our DataFrame that we are manipulating
    :param column: This is a column name as a string we are using to specify
        which column to sort by
    :param column_value_order: This is a dictionary of values that will
        represent precedence of the values in the specified column
    :param columns: This is a list of additional columns that we can sort by
    :raises ValueError: raises error if chosen Column Name is not in
        Dataframe, or if column_value_order dictionary is empty.
    :return: This function returns a Pandas DataFrame
    """
    if len(column_value_order) &gt; 0:
        if column in df.columns:
            df["cond_order"] = df[column].replace(column_value_order)
            if columns is None:
                new_df = df.sort_values("cond_order")
                del new_df["cond_order"]
            else:
                new_df = df.sort_values(columns + ["cond_order"])
                del new_df["cond_order"]
            return new_df
        else:
            raise ValueError("Column Name not in DataFrame")
    else:
        raise ValueError("column_value_order dictionary cannot be empty")
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.sort_naturally" class="doc doc-heading">
        <code>sort_naturally</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.sort_naturally.sort_naturally" class="doc doc-heading">
<code class="highlight language-python">sort_naturally(df, column_name, **natsorted_kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Sort a DataFrame by a column using <em>natural</em> sorting.</p>
<p>Natural sorting is distinct from
the default lexiographical sorting provided by <code>pandas</code>.
For example, given the following list of items:</p>
<pre class="highlight"><code>["A1", "A11", "A3", "A2", "A10"]
</code></pre>
<p>lexicographical sorting would give us:</p>
<pre class="highlight"><code>["A1", "A10", "A11", "A2", "A3"]
</code></pre>
<p>By contrast, "natural" sorting would give us:</p>
<pre class="highlight"><code>["A1", "A2", "A3", "A10", "A11"]
</code></pre>
<p>This function thus provides <em>natural</em> sorting
on a single column of a dataframe.</p>
<p>To accomplish this, we do a natural sort
on the unique values that are present in the dataframe.
Then, we reconstitute the entire dataframe
in the naturally sorted order.</p>
<p>Natural sorting is provided by the Python package
<a href="https://natsort.readthedocs.io/en/master/index.html">natsort</a></p>
<p>All keyword arguments to <code>natsort</code> should be provided
after the column name to sort by is provided.
They are passed through to the <code>natsorted</code> function.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor as jn

    df = pd.DataFrame(...)

    df = jn.sort_naturally(
        df=df,
        column_name='alphanumeric_column',
    )
</code></pre>
<p>Method chaining usage syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor

    df = pd.DataFrame(...)

    df = df.sort_naturally(
        column_name='alphanumeric_column',
    )
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>str</code></td>
        <td><p>The column on which natural sorting should take place.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>natsorted_kwargs</code></td>
        <td></td>
        <td><p>Keyword arguments to be passed to natsort's <code>natsorted</code> function.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A sorted pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/sort_naturally.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def sort_naturally(
    df: pd.DataFrame, column_name: str, **natsorted_kwargs
) -&gt; pd.DataFrame:
    """Sort a DataFrame by a column using *natural* sorting.

    Natural sorting is distinct from
    the default lexiographical sorting provided by `pandas`.
    For example, given the following list of items:

        ["A1", "A11", "A3", "A2", "A10"]

    lexicographical sorting would give us:


        ["A1", "A10", "A11", "A2", "A3"]

    By contrast, "natural" sorting would give us:

        ["A1", "A2", "A3", "A10", "A11"]

    This function thus provides *natural* sorting
    on a single column of a dataframe.

    To accomplish this, we do a natural sort
    on the unique values that are present in the dataframe.
    Then, we reconstitute the entire dataframe
    in the naturally sorted order.

    Natural sorting is provided by the Python package
    [natsort](https://natsort.readthedocs.io/en/master/index.html)

    All keyword arguments to `natsort` should be provided
    after the column name to sort by is provided.
    They are passed through to the `natsorted` function.

    Functional usage syntax:

    ```python
        import pandas as pd
        import janitor as jn

        df = pd.DataFrame(...)

        df = jn.sort_naturally(
            df=df,
            column_name='alphanumeric_column',
        )
    ```

    Method chaining usage syntax:

    ```python
        import pandas as pd
        import janitor

        df = pd.DataFrame(...)

        df = df.sort_naturally(
            column_name='alphanumeric_column',
        )
    ```
    :param df: A pandas DataFrame.
    :param column_name: The column on which natural sorting should take place.
    :param natsorted_kwargs: Keyword arguments to be passed
        to natsort's `natsorted` function.
    :returns: A sorted pandas DataFrame.
    """
    new_order = index_natsorted(df[column_name], **natsorted_kwargs)
    return df.iloc[new_order, :]
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.take_first" class="doc doc-heading">
        <code>take_first</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.take_first.take_first" class="doc doc-heading">
<code class="highlight language-python">take_first(df, subset, by, ascending=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Take the first row within each group specified by <code>subset</code>.</p>
<p>This method does not mutate the original DataFrame.</p>
<pre><code class="language-python">    import pandas as pd
    import janitor

    data = {
        &quot;a&quot;: [&quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;y&quot;],
        &quot;b&quot;: [0, 1, 2, 3]
    }
    df = pd.DataFrame(data)

    df.take_first(subset=&quot;a&quot;, by=&quot;b&quot;)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>subset</code></td>
        <td><code>Union[Hashable, Iterable[Hashable]]</code></td>
        <td><p>Column(s) defining the group.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>by</code></td>
        <td><code>Hashable</code></td>
        <td><p>Column to sort by.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ascending</code></td>
        <td><code>bool</code></td>
        <td><p>Whether or not to sort in ascending order, <code>bool</code>.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/take_first.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def take_first(
    df: pd.DataFrame,
    subset: Union[Hashable, Iterable[Hashable]],
    by: Hashable,
    ascending: bool = True,
) -&gt; pd.DataFrame:
    """
    Take the first row within each group specified by `subset`.

    This method does not mutate the original DataFrame.

    ```python
        import pandas as pd
        import janitor

        data = {
            "a": ["x", "x", "y", "y"],
            "b": [0, 1, 2, 3]
        }
        df = pd.DataFrame(data)

        df.take_first(subset="a", by="b")
    ```

    :param df: A pandas DataFrame.
    :param subset: Column(s) defining the group.
    :param by: Column to sort by.
    :param ascending: Whether or not to sort in ascending order, `bool`.
    :returns: A pandas DataFrame.
    """
    result = df.sort_values(by=by, ascending=ascending).drop_duplicates(
        subset=subset, keep="first"
    )

    return result
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.then" class="doc doc-heading">
        <code>then</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.then.then" class="doc doc-heading">
<code class="highlight language-python">then(df, func)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Add an arbitrary function to run in the <code>pyjanitor</code> method chain.</p>
<p>This method does not mutate the original DataFrame.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas dataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>func</code></td>
        <td><code>Callable</code></td>
        <td><p>A function you would like to run in the method chain. It should take one parameter and return one parameter, each being the DataFrame object. After that, do whatever you want in the middle. Go crazy.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/then.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def then(df: pd.DataFrame, func: Callable) -&gt; pd.DataFrame:
    """
    Add an arbitrary function to run in the `pyjanitor` method chain.

    This method does not mutate the original DataFrame.

    :param df: A pandas dataframe.
    :param func: A function you would like to run in the method chain.
        It should take one parameter and return one parameter, each being the
        DataFrame object. After that, do whatever you want in the middle.
        Go crazy.
    :returns: A pandas DataFrame.
    """
    df = func(df)
    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.to_datetime" class="doc doc-heading">
        <code>to_datetime</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.to_datetime.to_datetime" class="doc doc-heading">
<code class="highlight language-python">to_datetime(df, column_name, **kwargs)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Method-chainable <code>pd.to_datetime</code>.</p>
<p>This method mutates the original DataFrame.</p>
<p>Functional usage syntax:</p>
<pre><code class="language-python">    df = to_datetime(df, 'col1', format='%Y%m%d')
</code></pre>
<p>Method chaining syntax:</p>
<pre><code class="language-python">    import pandas as pd
    import janitor
    df = pd.DataFrame(...).to_datetime('col1', format='%Y%m%d')
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Column name.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>kwargs</code></td>
        <td></td>
        <td><p>provide any kwargs that <code>pd.to_datetime</code> can take.</p></td>
        <td><code>{}</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with updated datetime data.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/to_datetime.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(column="column_name")
def to_datetime(
    df: pd.DataFrame, column_name: Hashable, **kwargs
) -&gt; pd.DataFrame:
    """
    Method-chainable `pd.to_datetime`.

    This method mutates the original DataFrame.

    Functional usage syntax:

    ```python
        df = to_datetime(df, 'col1', format='%Y%m%d')
    ```

    Method chaining syntax:

    ```python
        import pandas as pd
        import janitor
        df = pd.DataFrame(...).to_datetime('col1', format='%Y%m%d')
    ```

    :param df: A pandas DataFrame.
    :param column_name: Column name.
    :param kwargs: provide any kwargs that `pd.to_datetime` can take.
    :returns: A pandas DataFrame with updated datetime data.
    """
    df[column_name] = pd.to_datetime(df[column_name], **kwargs)

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.toset" class="doc doc-heading">
        <code>toset</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.toset.toset" class="doc doc-heading">
<code class="highlight language-python">toset(series)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Return a set of the values.</p>
<p>These are each a scalar type, which is a Python scalar
(for str, int, float) or a pandas scalar
(for Timestamp/Timedelta/Interval/Period)</p>
<p>Functional usage syntax:</p>
<pre class="highlight"><code>import pandas as pd
import janitor as jn

series = pd.Series(...)
s = jn.functions.toset(series=series)
</code></pre>
<p>Method chaining usage example:</p>
<pre class="highlight"><code>import pandas as pd
import janitor

series = pd.Series(...)
s = series.toset()


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>series</code></td>
        <td><code>Series</code></td>
        <td><p>A pandas series.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Set</code></td>
      <td><p>A set of values.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/toset.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_series_method
def toset(series: pd.Series) -&gt; Set:
    """Return a set of the values.

    These are each a scalar type, which is a Python scalar
    (for str, int, float) or a pandas scalar
    (for Timestamp/Timedelta/Interval/Period)

    Functional usage syntax:



        import pandas as pd
        import janitor as jn

        series = pd.Series(...)
        s = jn.functions.toset(series=series)

    Method chaining usage example:



        import pandas as pd
        import janitor

        series = pd.Series(...)
        s = series.toset()

    :param series: A pandas series.
    :returns: A set of values.
    """

    return set(series.tolist())
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.transform_columns" class="doc doc-heading">
        <code>transform_columns</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.transform_columns.transform_column" class="doc doc-heading">
<code class="highlight language-python">transform_column(df, column_name, function, dest_column_name=None, elementwise=True)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Transform the given column in-place using the provided function.</p>
<p>Functions can be applied one of two ways:</p>
<ul>
<li>Element-wise (default; `elementwise=True``)</li>
<li>Column-wise  (alternative; `elementwise=False``)</li>
</ul>
<p>If the function is applied "elementwise",
then the first argument of the function signature
should be the individual element of each function.
This is the default behaviour of `transform_column``,
because it is easy to understand.
For example:</p>
<pre class="highlight"><code>def elemwise_func(x):
    modified_x = ... # do stuff here
    return modified_x

df.transform_column(column_name="my_column", function=elementwise_func)
</code></pre>
<p>On the other hand, columnwise application of a function
behaves as if the function takes in a pandas Series
and emits back a sequence that is of identical length to the original.
One place where this is desirable
is to gain access to <code>pandas</code> native string methods,
which are super fast!</p>
<pre class="highlight"><code>def columnwise_func(s: pd.Series) -&gt; pd.Series:
    return s.str[0:5]

df.transform_column(
    column_name="my_column",
    lambda s: s.str[0:5],
    elementwise=False
)
</code></pre>
<p>This method does not mutate the original DataFrame.</p>
<p>Let's say we wanted to apply a log10 transform a column of data.</p>
<p>Originally one would write code like this:</p>
<pre class="highlight"><code># YOU NO LONGER NEED TO WRITE THIS!
df[column_name] = df[column_name].apply(np.log10)
</code></pre>
<p>With the method chaining syntax, we can do the following instead:</p>
<pre class="highlight"><code>df = (
    pd.DataFrame(...)
    .transform_column(column_name, np.log10)
)
</code></pre>
<p>With the functional syntax:</p>
<pre class="highlight"><code>df = pd.DataFrame(...)
df = transform_column(df, column_name, np.log10)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>The column to transform.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>function</code></td>
        <td><code>Callable</code></td>
        <td><p>A function to apply on the column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dest_column_name</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>The column name to store the transformation result in. Defaults to None, which will result in the original column name being overwritten. If a name is provided here, then a new column with the transformed values will be created.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>elementwise</code></td>
        <td><code>bool</code></td>
        <td><p>Whether to apply the function elementwise or not. If elementwise is True, then the function's first argument should be the data type of each datum in the column of data, and should return a transformed datum. If elementwise is False, then the function's should expect a pandas Series passed into it, and return a pandas Series.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with a transformed column.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/transform_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(col_name="column_name", dest_col_name="dest_column_name")
def transform_column(
    df: pd.DataFrame,
    column_name: Hashable,
    function: Callable,
    dest_column_name: Optional[str] = None,
    elementwise: bool = True,
) -&gt; pd.DataFrame:
    """Transform the given column in-place using the provided function.

    Functions can be applied one of two ways:

    - Element-wise (default; `elementwise=True``)
    - Column-wise  (alternative; `elementwise=False``)

    If the function is applied "elementwise",
    then the first argument of the function signature
    should be the individual element of each function.
    This is the default behaviour of `transform_column``,
    because it is easy to understand.
    For example:



        def elemwise_func(x):
            modified_x = ... # do stuff here
            return modified_x

        df.transform_column(column_name="my_column", function=elementwise_func)

    On the other hand, columnwise application of a function
    behaves as if the function takes in a pandas Series
    and emits back a sequence that is of identical length to the original.
    One place where this is desirable
    is to gain access to `pandas` native string methods,
    which are super fast!



        def columnwise_func(s: pd.Series) -&gt; pd.Series:
            return s.str[0:5]

        df.transform_column(
            column_name="my_column",
            lambda s: s.str[0:5],
            elementwise=False
        )

    This method does not mutate the original DataFrame.

    Let's say we wanted to apply a log10 transform a column of data.

    Originally one would write code like this:



        # YOU NO LONGER NEED TO WRITE THIS!
        df[column_name] = df[column_name].apply(np.log10)

    With the method chaining syntax, we can do the following instead:



        df = (
            pd.DataFrame(...)
            .transform_column(column_name, np.log10)
        )

    With the functional syntax:



        df = pd.DataFrame(...)
        df = transform_column(df, column_name, np.log10)

    :param df: A pandas DataFrame.
    :param column_name: The column to transform.
    :param function: A function to apply on the column.
    :param dest_column_name: The column name to store the transformation result
        in. Defaults to None, which will result in the original column
        name being overwritten. If a name is provided here, then a new column
        with the transformed values will be created.
    :param elementwise: Whether to apply the function elementwise or not.
        If elementwise is True, then the function's first argument
        should be the data type of each datum in the column of data,
        and should return a transformed datum.
        If elementwise is False, then the function's should expect
        a pandas Series passed into it, and return a pandas Series.

    :returns: A pandas DataFrame with a transformed column.
    """
    if dest_column_name is None:
        dest_column_name = column_name

    if elementwise:
        result = df[column_name].apply(function)
    else:
        result = function(df[column_name])

    df = df.assign(**{dest_column_name: result})
    return df
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.transform_columns.transform_columns" class="doc doc-heading">
<code class="highlight language-python">transform_columns(df, column_names, function, suffix=None, elementwise=True, new_column_names=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Transform multiple columns through the same transformation.</p>
<p>This method mutates the original DataFrame.</p>
<p>Super syntactic sugar!</p>
<p>Basically wraps <code>transform_column</code> and calls it repeatedly over all column
names provided.</p>
<p>User can optionally supply either a suffix to create a new set of columns
with the specified suffix, or provide a dictionary mapping each original
column name to its corresponding new column name. Note that all column
names must be strings.</p>
<p>A few examples below. Firstly, to just log10 transform a list of columns
without creating new columns to hold the transformed values:</p>
<pre class="highlight"><code>df = (
    pd.DataFrame(...)
    .transform_columns(['col1', 'col2', 'col3'], np.log10)
)
</code></pre>
<p>Secondly, to add a '_log' suffix when creating a new column, which we think
is going to be the most common use case:</p>
<pre class="highlight"><code>df = (
    pd.DataFrame(...)
    .transform_columns(
        ['col1', 'col2', 'col3'],
        np.log10,
        suffix="_log"
    )
)
</code></pre>
<p>Finally, to provide new names explicitly:</p>
<pre class="highlight"><code>df = (
    pd.DataFrame(...)
    .transform_column(
        ['col1', 'col2', 'col3'],
        np.log10,
        new_column_names={
            'col1': 'transform1',
            'col2': 'transform2',
            'col3': 'transform3',
            }
        )
)


</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>A pandas DataFrame.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Union[List[str], Tuple[str]]</code></td>
        <td><p>An iterable of columns to transform.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>function</code></td>
        <td><code>Callable</code></td>
        <td><p>A function to apply on each column.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>suffix</code></td>
        <td><code>Optional[str]</code></td>
        <td><p>(optional) Suffix to use when creating new columns to hold the transformed values.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>elementwise</code></td>
        <td><code>bool</code></td>
        <td><p>Passed on to <code>transform_column</code>; whether or not to apply the transformation function elementwise (True) or columnwise (False).</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>new_column_names</code></td>
        <td><code>Optional[Dict[str, str]]</code></td>
        <td><p>(optional) An explicit mapping of old column names to new column names.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame with transformed columns.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if both <code>suffix</code> and <code>new_column_names</code> are specified</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/transform_columns.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(columns="column_names", new_names="new_column_names")
def transform_columns(
    df: pd.DataFrame,
    column_names: Union[List[str], Tuple[str]],
    function: Callable,
    suffix: Optional[str] = None,
    elementwise: bool = True,
    new_column_names: Optional[Dict[str, str]] = None,
) -&gt; pd.DataFrame:
    """Transform multiple columns through the same transformation.

    This method mutates the original DataFrame.

    Super syntactic sugar!

    Basically wraps `transform_column` and calls it repeatedly over all column
    names provided.

    User can optionally supply either a suffix to create a new set of columns
    with the specified suffix, or provide a dictionary mapping each original
    column name to its corresponding new column name. Note that all column
    names must be strings.

    A few examples below. Firstly, to just log10 transform a list of columns
    without creating new columns to hold the transformed values:



        df = (
            pd.DataFrame(...)
            .transform_columns(['col1', 'col2', 'col3'], np.log10)
        )

    Secondly, to add a '_log' suffix when creating a new column, which we think
    is going to be the most common use case:



        df = (
            pd.DataFrame(...)
            .transform_columns(
                ['col1', 'col2', 'col3'],
                np.log10,
                suffix="_log"
            )
        )

    Finally, to provide new names explicitly:



        df = (
            pd.DataFrame(...)
            .transform_column(
                ['col1', 'col2', 'col3'],
                np.log10,
                new_column_names={
                    'col1': 'transform1',
                    'col2': 'transform2',
                    'col3': 'transform3',
                    }
                )
        )

    :param df: A pandas DataFrame.
    :param column_names: An iterable of columns to transform.
    :param function: A function to apply on each column.
    :param suffix: (optional) Suffix to use when creating new columns to hold
        the transformed values.
    :param elementwise: Passed on to `transform_column`; whether or not
        to apply the transformation function elementwise (True)
        or columnwise (False).
    :param new_column_names: (optional) An explicit mapping of old column names
        to new column names.
    :returns: A pandas DataFrame with transformed columns.
    :raises ValueError: if both `suffix` and `new_column_names` are
        specified
    """
    dest_column_names = dict(zip(column_names, column_names))

    check("column_names", column_names, [list, tuple])

    if suffix is not None and new_column_names is not None:
        raise ValueError(
            "only one of suffix or new_column_names should be specified"
        )

    if suffix:  # If suffix is specified...
        check("suffix", suffix, [str])
        for col in column_names:
            dest_column_names[col] = col + suffix

    if new_column_names:  # If new_column_names is specified...
        check("new_column_names", new_column_names, [dict])
        dest_column_names = new_column_names

    # Now, transform columns.
    for old_col, new_col in dest_column_names.items():
        df = transform_column(
            df, old_col, function, new_col, elementwise=elementwise
        )

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.truncate_datetime" class="doc doc-heading">
        <code>truncate_datetime</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.truncate_datetime.truncate_datetime_dataframe" class="doc doc-heading">
<code class="highlight language-python">truncate_datetime_dataframe(df, datepart)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Truncate times down to a user-specified precision of
year, month, day, hour, minute, or second.</p>
<p>Call on datetime object to truncate it.
Calling on existing df will not alter the contents
of said df.</p>
<p>Note: Truncating down to a Month or Day will yields 0s,
as there is no 0 month or 0 day in most datetime systems.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The dataframe on which to truncate datetime.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>datepart</code></td>
        <td><code>str</code></td>
        <td><p>Truncation precision, YEAR, MONTH, DAY, HOUR, MINUTE, SECOND. (String is automagically capitalized)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>a truncated datetime object to the precision specified by datepart.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/truncate_datetime.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
def truncate_datetime_dataframe(
    df: pd.DataFrame, datepart: str
) -&gt; pd.DataFrame:
    """
    Truncate times down to a user-specified precision of
    year, month, day, hour, minute, or second.

    Call on datetime object to truncate it.
    Calling on existing df will not alter the contents
    of said df.

    Note: Truncating down to a Month or Day will yields 0s,
    as there is no 0 month or 0 day in most datetime systems.

    :param df: The dataframe on which to truncate datetime.
    :param datepart: Truncation precision, YEAR, MONTH, DAY,
        HOUR, MINUTE, SECOND. (String is automagically
        capitalized)

    :returns: a truncated datetime object to
        the precision specified by datepart.
    """
    for i in df.columns:
        for j in df.index:
            try:
                df[i][j] = _truncate_datetime(datepart, df[i][j])
            except KeyError:
                pass
            except TypeError:
                pass
            except AttributeError:
                pass

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.update_where" class="doc doc-heading">
        <code>update_where</code>



</h2>

    <div class="doc doc-contents ">




  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.update_where.update_where" class="doc doc-heading">
<code class="highlight language-python">update_where(df, conditions, target_column_name, target_val)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Add multiple conditions to update a column in the dataframe.</p>
<p>This method does not mutate the original DataFrame.</p>
<p>Example usage:</p>
<pre><code class="language-python">    data = {
        &quot;a&quot;: [1, 2, 3, 4],
        &quot;b&quot;: [5, 6, 7, 8],
        &quot;c&quot;: [0, 0, 0, 0]
    }
    df = pd.DataFrame(data)

       a  b  c
    0  1  5  0
    1  2  6  0
    2  3  7  0
    3  4  8  0

    df.update_where(conditions = (df.a &gt; 2) &amp; (df.b &lt; 8),
                    target_column_name = 'c',
                    target_val = 10)

       a  b   c
    0  1  5   0
    1  2  6   0
    2  3  7  10
    3  4  8   0
</code></pre>
<p><code>update_where</code> also supports pandas <em>query</em> style string expressions:</p>
<pre><code class="language-python">    df.update_where(conditions = &quot;a &gt; 2 and b &lt; 8&quot;,
                    target_column_name = 'c',
                    target_val = 10)

       a  b   c
    0  1  5   0
    1  2  6   0
    2  3  7  10
    3  4  8   0
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>DataFrame</code></td>
        <td><p>The pandas DataFrame object.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>conditions</code></td>
        <td><code>Any</code></td>
        <td><p>Conditions used to update a target column and target value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>target_column_name</code></td>
        <td><code>Hashable</code></td>
        <td><p>Column to be updated. If column does not exist in DataFrame, a new column will be created; note that entries that do not get set in the new column will be null.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>target_val</code></td>
        <td><code>Any</code></td>
        <td><p>Value to be updated</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>DataFrame</code></td>
      <td><p>A pandas DataFrame.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ValueError</code></td>
        <td><p>if <code>conditions</code> does not return a boolean array-like data structure.  .. # noqa: DAR402</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/update_where.py</code></summary>
          <pre class="highlight"><code class="language-python">@pf.register_dataframe_method
@deprecated_alias(target_col="target_column_name")
def update_where(
    df: pd.DataFrame,
    conditions: Any,
    target_column_name: Hashable,
    target_val: Any,
) -&gt; pd.DataFrame:
    """
    Add multiple conditions to update a column in the dataframe.

    This method does not mutate the original DataFrame.

    Example usage:

    ```python
        data = {
            "a": [1, 2, 3, 4],
            "b": [5, 6, 7, 8],
            "c": [0, 0, 0, 0]
        }
        df = pd.DataFrame(data)

           a  b  c
        0  1  5  0
        1  2  6  0
        2  3  7  0
        3  4  8  0

        df.update_where(conditions = (df.a &gt; 2) &amp; (df.b &lt; 8),
                        target_column_name = 'c',
                        target_val = 10)

           a  b   c
        0  1  5   0
        1  2  6   0
        2  3  7  10
        3  4  8   0
    ```

    `update_where` also supports pandas *query* style string expressions:

    ```python
        df.update_where(conditions = "a &gt; 2 and b &lt; 8",
                        target_column_name = 'c',
                        target_val = 10)

           a  b   c
        0  1  5   0
        1  2  6   0
        2  3  7  10
        3  4  8   0
    ```


    :param df: The pandas DataFrame object.
    :param conditions: Conditions used to update a target column
        and target value.
    :param target_column_name: Column to be updated. If column does not exist
        in DataFrame, a new column will be created; note that entries that do
        not get set in the new column will be null.
    :param target_val: Value to be updated
    :returns: A pandas DataFrame.
    :raises ValueError: if `conditions` does not return a boolean array-like
        data structure.

    .. # noqa: DAR402
    """

    df = df.copy()

    # use query mode if a string expression is passed
    if isinstance(conditions, str):
        conditions = df.eval(conditions)

    if not is_bool_dtype(conditions):
        raise ValueError(
            """
            Kindly ensure that `conditions` passed
            evaluates to a Boolean dtype.
            """
        )

    df.loc[conditions, target_column_name] = target_val

    return df
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">



<h2 id="janitor.functions.utils" class="doc doc-heading">
        <code>utils</code>



</h2>

    <div class="doc doc-contents ">

      <p>Utility functions for all of the functions submodule.</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.utils.patterns" class="doc doc-heading">
<code class="highlight language-python">patterns(regex_pattern)</code>


</h3>

    <div class="doc doc-contents ">

      <p>This function converts a string into a compiled regular expression;
it can be used to select columns in the index or columns_names
arguments of <code>pivot_longer</code> function.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>regex_pattern</code></td>
        <td><code>Union[str, Pattern]</code></td>
        <td><p>string to be converted to compiled regular expression.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Pattern</code></td>
      <td><p>A compile regular expression from provided <code>regex_pattern</code>.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/utils.py</code></summary>
          <pre class="highlight"><code class="language-python">def patterns(regex_pattern: Union[str, Pattern]) -&gt; Pattern:
    """
    This function converts a string into a compiled regular expression;
    it can be used to select columns in the index or columns_names
    arguments of `pivot_longer` function.

    :param regex_pattern: string to be converted to compiled regular
        expression.
    :returns: A compile regular expression from provided
        `regex_pattern`.
    """
    check("regular expression", regex_pattern, [str, Pattern])

    return re.compile(regex_pattern)
</code></pre>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h3 id="janitor.functions.utils.unionize_dataframe_categories" class="doc doc-heading">
<code class="highlight language-python">unionize_dataframe_categories(*dataframes, *, column_names=None)</code>


</h3>

    <div class="doc doc-contents ">

      <p>Given a group of dataframes which contain some categorical columns, for
each categorical column present, find all the possible categories across
all the dataframes which have that column.
Update each dataframes' corresponding column with a new categorical object
that contains the original data
but has labels for all the possible categories from all dataframes.
This is useful when concatenating a list of dataframes which all have the
same categorical columns into one dataframe.</p>
<p>If, for a given categorical column, all input dataframes do not have at
least one instance of all the possible categories,
Pandas will change the output dtype of that column from <code>category</code> to
<code>object</code>, losing out on dramatic speed gains you get from the former
format.</p>
<p>Usage example for concatenation of categorical column-containing
dataframes:</p>
<p>Instead of:</p>
<pre><code class="language-python">concatenated_df = pd.concat([df1, df2, df3], ignore_index=True)
</code></pre>
<p>which in your case has resulted in <code>category</code> -&gt; <code>object</code> conversion,
use:</p>
<pre><code class="language-python">unionized_dataframes = unionize_dataframe_categories(df1, df2, df2)
concatenated_df = pd.concat(unionized_dataframes, ignore_index=True)
</code></pre>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dataframes</code></td>
        <td></td>
        <td><p>The dataframes you wish to unionize the categorical objects for.</p></td>
        <td><code>()</code></td>
      </tr>
      <tr>
        <td><code>column_names</code></td>
        <td><code>Optional[Iterable[pandas.core.dtypes.dtypes.CategoricalDtype]]</code></td>
        <td><p>If supplied, only unionize this subset of columns.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>List[pandas.core.frame.DataFrame]</code></td>
      <td><p>A list of the category-unioned dataframes in the same order they were provided.</p></td>
    </tr>
  </tbody>
</table>
<p><strong>Exceptions:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>TypeError</code></td>
        <td><p>If any of the inputs are not pandas DataFrames.</p></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>janitor/functions/utils.py</code></summary>
          <pre class="highlight"><code class="language-python">def unionize_dataframe_categories(
    *dataframes, column_names: Optional[Iterable[pd.CategoricalDtype]] = None
) -&gt; List[pd.DataFrame]:
    """
    Given a group of dataframes which contain some categorical columns, for
    each categorical column present, find all the possible categories across
    all the dataframes which have that column.
    Update each dataframes' corresponding column with a new categorical object
    that contains the original data
    but has labels for all the possible categories from all dataframes.
    This is useful when concatenating a list of dataframes which all have the
    same categorical columns into one dataframe.

    If, for a given categorical column, all input dataframes do not have at
    least one instance of all the possible categories,
    Pandas will change the output dtype of that column from `category` to
    `object`, losing out on dramatic speed gains you get from the former
    format.

    Usage example for concatenation of categorical column-containing
    dataframes:

    Instead of:

    ```python
    concatenated_df = pd.concat([df1, df2, df3], ignore_index=True)
    ```

    which in your case has resulted in `category` -&gt; `object` conversion,
    use:

    ```python
    unionized_dataframes = unionize_dataframe_categories(df1, df2, df2)
    concatenated_df = pd.concat(unionized_dataframes, ignore_index=True)
    ```

    :param dataframes: The dataframes you wish to unionize the categorical
        objects for.
    :param column_names: If supplied, only unionize this subset of columns.
    :returns: A list of the category-unioned dataframes in the same order they
        were provided.
    :raises TypeError: If any of the inputs are not pandas DataFrames.
    """

    if any(not isinstance(df, pd.DataFrame) for df in dataframes):
        raise TypeError("Inputs must all be dataframes.")

    if column_names is None:
        # Find all columns across all dataframes that are categorical

        column_names = set()

        for dataframe in dataframes:
            column_names = column_names.union(
                [
                    column_name
                    for column_name in dataframe.columns
                    if isinstance(
                        dataframe[column_name].dtype, pd.CategoricalDtype
                    )
                ]
            )

    else:
        column_names = [column_names]
    # For each categorical column, find all possible values across the DFs

    category_unions = {
        column_name: union_categoricals(
            [df[column_name] for df in dataframes if column_name in df.columns]
        )
        for column_name in column_names
    }

    # Make a shallow copy of all DFs and modify the categorical columns
    # such that they can encode the union of all possible categories for each.

    refactored_dfs = []

    for df in dataframes:
        df = df.copy(deep=False)

        for column_name, categorical in category_unions.items():
            if column_name in df.columns:
                df[column_name] = pd.Categorical(
                    df[column_name], categories=categorical.categories
                )

        refactored_dfs.append(df)

    return refactored_dfs
</code></pre>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>




  </div>

    </div>

  </div>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../../devguide/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Development Guide" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Development Guide
            </div>
          </div>
        </a>
      
      
        
        <a href="../biology/" class="md-footer__link md-footer__link--next" aria-label="Next: Biology" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Biology
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["instant"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.fcfe8b6d.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.b1047164.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
      
        <script src="../../js/config.js"></script>
      
    
  </body>
</html>